[
    
    
    {
        "url": "/brands/",
        "title": "Brands",
        "content": "Brands som Kiils råder over. Hosted på platformen Folkets\n"
    }
    
    , 
    {
        "url": "/cases/",
        "title": "Cases",
        "content": "Under linket til hver enkelt case er nogle af mine erfaringer med pågældende case også linket. Jo, man lærer meget hen ad vejen.\n"
    }
    
    , 
    {
        "url": "/emner/",
        "title": "Emner",
        "content": "Emner i det arbejde Kiils laver\n"
    }
    
    , 
    {
        "url": "/erfaringer/",
        "title": "Erfaringer",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/facebook/",
        "title": "facebook",
        "content": ""
    }
    
    , 
    {
        "url": "/cases/folkets/",
        "title": "FOLKETS",
        "content": "En dansk brand- og medieplatform\nFOLKETS.DK er et enorm stort projekt. Visionen er at udfordre både de danske medier og de amerikanske \u0026ldquo;tech giants\u0026rdquo;.\nSamtidig med at øjnene skal holdes på dette langsigtede mål, skal de betalende brugere også løbende serviceres med godt indhold.\nDer skal skabes indtægter og hele projektet skal løbende tilpasses og \u0026ldquo;trimmes\u0026rdquo; da der hele tiden kommer nyt på.\nFOLKETS.DK er uden sammenligning det mest lærerige fagligt set, som jeg har foretaget mig i mit arbejdsliv.\n"
    }
    
    , 
    {
        "url": "/brands/folkets-avis/",
        "title": "Folkets Avis",
        "content": "Folkets Avis er et mediebrand på udgiverplatformen FOLKETS.\nLennart Kiil En dansk brand- og medieplatform\nFOLKETS.DK er et enorm stort projekt. Visionen er at udfordre både de danske medier og de amerikanske \u0026ldquo;tech giants\u0026rdquo;.\nSamtidig med at øjnene skal holdes på dette langsigtede mål, skal de betalende brugere også løbende serviceres med godt indhold.\nDer skal skabes indtægter og hele projektet skal løbende tilpasses og \u0026ldquo;trimmes\u0026rdquo; da der hele tiden kommer nyt på.\nFOLKETS.DK er uden sammenligning det mest lærerige fagligt set, som jeg har foretaget mig i mit arbejdsliv.\n"
    }
    
    , 
    {
        "url": "/erfaringer/some/facebook/fald/",
        "title": "Jeg har brudt koden på facebook!",
        "content": "En samarbejdspartner fortalte mig for ikke så længe siden:\n– Jeg har brudt koden på facebook!\n– Hvordan?\n– Man betaler bare.\nJo, det tror jeg gerne på.\nEnhver som arbejder med markedsføring eller mediedrift på facebook ved at facebook gør meget ud af at oplyse en om mulighederne for at øge rækkevidden ved at betale for boost af ens indhold.\nDer levnes ingen tvivl om at facebook gerne vil have at man bruger penge på at promovere sine sider og sine ikke-personlige indlæg.\nDer dukker meget ofte forskellige former for påmindelser op om at dette er muligt. Og hvis man betaler og for sat sin målgruppe rigtigt sammen, så kan man sikkert ofte få en del \u0026ldquo;bang for the buck\u0026rdquo;.\nMen det er ikke bare de direkte opfordringer, facebook kommer med, som underbygger teorien om at der skal bruges penge på facebook hvis man vil have hurtige resultater.\nHer ses udviklingen i antal følgere på Folkets Avis\u0026rsquo; facebookside nogle måneder i slutningen af 2019:\nJeg bemærker en jævn langsomt nedadgående trend. Det på trods af at der ellers ofte er interesse og engagement på siden.\nJeg ville ikke blive overrasket hvis facebook arbejder med deres algoritmer på en måde så der falder flere fra end der kommer til - med mindre særlige forhold gør sig gældende.\nSå kan man enten være meget dygtig og dedikeret i sin jagt på flere følgere. Eller man kan betale sig fra det. Eller, naturligvis, kombinere de to tilgange.\nJeg skal her være ærlig:\nSom medieejer er facebook blevet mindre interessant. For for et givet antal følgere er det nu sværere end tidligere at få folk ud af facebooks lukkede have.\nDet er derfor mest sandsynligt at jeg koncentrerer mere af min indsats andre steder fremover. Om at opbygge medieplatformen FOLKETS yderligere.\nFor andre kan facebook til stadighed være en central del af forretningen.\nMen det kræver som hovedregel en betydelig investering af både tid og efterhånden også penge at få ordentligt udbytte af indsatsen.\nDe nemme tider med facebook er for længst forbi.\n"
    }
    
    , 
    {
        "url": "/",
        "title": "Kiils | digitalt mediebureau",
        "content": " 17 års praktisk erfaring i krydsfeltet mellem internet, journalistik og sociale medier Måske kan jeg hjælpe dig? Kontakt mig nu!  "
    }
    
    , 
    {
        "url": "/skribenter/lennart-kiil/",
        "title": "Lennart Kiil",
        "content": "Lennart Kiil kan også findes på FOLKETS , og på LinkedIn .\n"
    }
    
    , 
    {
        "url": "/skribenter/",
        "title": "Skribenter",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/some/",
        "title": "SoMe",
        "content": ""
    }
    
    , 
    {
        "url": "/erfaringer/fundraising/copydan/copydan-digital/",
        "title": "100.000 gange årligt bruges mine tekster i undervisningen uden at jeg får en krone for det – og CopyDan kan ikke hjælpe mig",
        "content": "På grund af forældet lovgivning kan CopyDan ikke hjælpe mig.\nLad mig forklare sagen:\nJeg er meget glad for og stolt over Klimaleksikon - Danmarks bedste sted for børn og unge at blive klogere på alt hvad der har med klima at gøre.\nSitet virker på alle måder efter hensigten og hjælper hvert år cirka 100.000 børn og unge med at få mere viden om klima og klimarelaterede emner.\nDet kan jeg kun være enormt tilfreds med.\nOg både politikere og erhvervsliv kan slet ikke holde op med at fortælle om hvor vigtigt emnet er.\nSå er det godt at hjælpe med at klæde børn og unge fagligt på til at forstå mekanismerne bag klimaforandringer.\nMen der er også meget følelsesbetonet og irrationel debat om klima i Danmark. Ikke mindst blandt voksne mennesker.\nDet har skabt en situation hvor emnet klima for mange børn og unge er blevet en debiliterende ting i deres hverdag som gør dem bekymrede og kede af det.\nOplysning, af den art som Klimaleksikon leverer med fokus på det faktuelle, kan også være med til at modvirke de debiliterende tendenser til klimaangst i børn.\nOg give dem en forståelse af hvad vi mennesker kan gøre for at imødegå klimaforandringer med hjælp fra vores intelligens og fornuft – og vores enestående evne til at udvikle teknologiske løsninger.\nSom en ekstra bonus kan klima, som emnet tilgås på Klimaleksikon, engagere flere piger i STEM-fagene og STEAM-fagene. Noget som mange mener er meget vigtigt.\nDet lyder jo alt sammen meget godt.\nMen, men, men.\nJeg har nu i 11 år af egen pengepung betalt for at holde Klimaleksikon kørende. Jeg har betalt professionelle fagformidlere for at lave indhold og holde indhold opdateret.\nDet kan jeg ikke blive ved med.\nOg da jeg på forskellig vis kunne se at Klimaleksikon blev aktivt brugt i undervisningen kontaktede jeg CopyDan.\nCopyDan sender nemlig med lovhjemmel fakturaer ud til uddannelsesinstitutionerne på vegne af udgivere og autorer.\nDe var utroligt flinke og rare inde på CopyDan. Men de kunne til min forbløffelse absolut intet gøre for at hjælpe mig.\nPå trods af jeg er både udgiver og autor, som CopyDan kalder forfattere og skribenter, så kunne de ikke hjælpe mig.\nSelvom de jo egentligt som nævnt kræver penge ind fra netop uddannelsesinstitutionerne på vegne af netop sådan nogle som mig, der skaber tekster og andet indhold som bruges massivt i undervisningen.\nOg på trods af at jeg kan bevise dette.\nHer er for eksempel en liste over de ti sites jeg har flest henvisninger fra:\nSom I kan se, så er det hovedsageligt forskellige læringsplatforme som bruges af folkeskoler og ungdomsuddannelser som dominerer de øverste pladser.\nDet betyder at lærere aktivt linker til og altså bruger mit materiale i deres undervisning. Og med god grund.\nOg hvis vi ser på hvornår Klimaleksikon bliver benyttet, så er det også klart i skoletiden:\nMen selvom mit materiale bliver massivt benyttet i undervisningen, også af lærerne, så kan jeg intet få fra CopyDan.\nFordi det foregår digitalt. Og fordi der \u0026ldquo;kun\u0026rdquo; i teknisk forstand foretages en kopiering (af filer ned i elevens browser når de klikker det link som læreren deler med dem.)\nHavde jeg udgivet en håndgribelig fysisk bog som var blevet kopieret og benyttet i undervisningen i samme omgang, så var jeg blevet betalt for det.\nDet virker som om lovgivningen ikke er fulgt med tiden.\nDet kan jeg bare ikke bruge til specielt meget, jeg kan blot konstatere at mange andre, som får deres materiale benyttet i mindre omfang end mig, de får penge for det - mens jeg ikke får en krone.\nSå indtil videre må jeg glæde mig over at have været idealist og gennem 11 år at have gjort over en million mennesker klogere på klima. Gjort flere piger interesserede i tekniske og naturvidenskabelige fag. Og måske endda have forhindret eller afhjulpet klimaangst blandt en del børn.\nOg det er altsammen bestemt også ganske værdifuldt.\n"
    }
    
    , 
    {
        "url": "/emner/copydan/",
        "title": "CopyDan",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/finansiering/",
        "title": "finansiering",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/fundraising/",
        "title": "fundraising",
        "content": ""
    }
    
    , 
    {
        "url": "/cases/klimaleksikon/",
        "title": "Klimaleksikon",
        "content": "Klimaleksikon.dk er med over 11 år på bagen Danmarks bedste og længstlevende side om klima .\nSiden er et samarbejde mellem mig og to andre naturfagsformidlere, Thomas Hesselberg og Mikkel Houmøller. Siden indeholder omkring 100 opslag på centrale emner inden for klima og klarer sig enormt godt i google-søgninger.\nSiden holdes løbende opdateret, og hundredetusinder af børn og unge har lært om klima og energi på siden.\nSidens brugere er overvejende børn i folkeskolens ældste klasser og unge på ungdomsuddannelserne.\nLærerne bruger aktivt Klimaleksikon i undervisningen, det ses blandt andet af de mange henvisninger fra diverse undervisningsplatforme:\nDesuden ser vi at Klimaleksikon hovedsageligt finder anvendelse inden for den almindelige undervisningstid:\nDer er en overvægt af piger hvilket er en smule atypisk for en side som i bund og grund er naturvidenskabeligt orienteret og skabt af naturfagsformidlere.\nMen det viser i hvert fald at interessen i naturvidenskab og teknologi er der fra den kant også når det overordnede emne blot er vedkommende nok.\nOpslagene, som er kerneindholdet på siden, er naturligvis skrevet i et tilgængeligt sprog som passer til målgruppen af unge mennesker. Men mange granvoksne har skam også glæde af siden. På en række af opslagene har vi nederst spørgsmål, som brugeren kan besvare og dermed få en fornemmelse af om man fået fat i de væsentligste oplysninger i teksten ovenfor.\nSiden er strengt apolitisk og faktuelt baseret. Det er en aftale jeg selv er glad for, da der er en stor lettelse i at være involveret i noget som er ent fakta-orienteret. Jeg nyder virkelig at have et frirum for politik og har derfor meget let ved at adskille Klimaleksikon fra mit øvrige virke.\n"
    }
    
    , 
    {
        "url": "/emner/%C3%B8konomi/",
        "title": "økonomi",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/crowdfunding/",
        "title": "crowdfunding",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/cta/",
        "title": "cta",
        "content": ""
    }
    
    , 
    {
        "url": "/tools/donorbox/",
        "title": "donorbox",
        "content": ""
    }
    
    , 
    {
        "url": "/erfaringer/fundraising/klimaleksikon-crowdfunding-donorbox/",
        "title": "Kan man crowdfunde et klimaleksikon?",
        "content": "Klimaleksikon er en meget væsentlig dansk kilde til især unge menneskers viden om klima og klimaændring.\nOm to måneder fejrer Klimaleksikon 11 års fødselsdag på nettet. Jeg har personligt sørget for at over en million mennesker i den periode er blevet klogere på klima. Det har jeg gjort rent pro bono.\nMen det koster at udvikle og holde et klimaleksikon up to date, og jeg har derfor besluttet at jeg vil skabe et økonomisk fundament for Klimaleksikon der gør at jeg i det mindste får dækket mine udgifter ind fremover.\nJeg har kontaktet et stort antal danske virksomheder, men de var ikke interesserede i at bidrage til at udbrede viden om klima. Til trods for at de i pressen fører sig frem som de store klimaforkæmpere.\nNuvel, deres penge - deres prioriteringer.\nJeg vil nu undersøge om der blandt befolkningen bredt set er en større reel interesse for at sætte sine penge der hvor snakken går.\nDerfor har jeg lavet en crowdfunding med følgende ordlyd:\n Lennart Kiil har gennem 11 år for egen regning drevet Klimaleksikon. I den periode er over en million mennesker blevet klogere på klima på grund af Klimaleksikon.\nKlimaleksikon bruges dagligt af især unge over hele landet når de søger viden om klima og relaterede emner. Det er vigtigt at de ved der findes en anden mulighed end at pjække fra skole. Klimaleksikon sørger for at der også er at sted på nettet for dem som vil lære noget og søger at tilgå klimaproblemet konstruktivt.\nDen vidensbaserede og fornuftige tilgang er nu vigtigere end nogensinde før. Vi risikerer at spørgsmålet om klima bliver overtaget af politiske aktivister.\nMen det er dyrt at holde et klimaleksikon kørende, udvikle det og give så mange mennesker i alle aldre mere viden. Det koster årligt titusindvis af kroner.\nDerfor mener Lennart Kiil at det er på tide at flere træder til og bakker op om Klimaleksikon som baserer sig på viden frem for følelser i klimaspørgsmålet. Desværre har danske virksomheder, som ellers taler meget om klima, hidtil vist sig uvillige til at bakke op om og sponsorere det vidensbaserede Klimaleksikon.\nSå nu må almindelige borgere og gode mennesker træde til!\n På Klimaleksikon har jeg valgt at holde call to action diskret i første omgang.\nDet ser sådan her ud:\nDette CTA sender en videre til en formular.\nDenne formular kan både ses og bruges lige herunder, så du er naturligvis velkommen til at yde et bidrag til Klimaleksikon hvis du har lyst til at støtte en videns- og fornuftsbaseret tilgang til klimaproblemet.\n Det bliver spændende om der er opbakning :)\n"
    }
    
    , 
    {
        "url": "/tools/",
        "title": "Tools",
        "content": ""
    }
    
    , 
    {
        "url": "/cm/",
        "title": "Cm",
        "content": ""
    }
    
    , 
    {
        "url": "/cases/gastrofun/",
        "title": "Gastro Fun",
        "content": "For mig er der en ekstra tilfredsstillelse ved at arbejde på ting hvor jeg har været med fra starten til at lægge fundamentet. Og det var tilfældet med madsitet GastroFun.dk .\nSammen med Per Asmussen byggede jeg GastroFun.dk fra bunden. Vi har været gode til at finde de rigtige løsninger i forhold til indholdsstruktur og informationsarkitektur.\nSiden har allerede opnået en meget prominent placering i Googles søgemaskine hvilket har været et centralt succeskriterie.\nPer er meget ambitiøs med siden, og det passer mig godt. I dag er udvikling på nettet altid noget løbende fordi konkurrenterne hele tiden er i bevægelse.\nJeg er derfor fortsat med til at rådgive og løse konkrete udfordringer på GastroFun.dk så siden forhåbentligt kan klare sig endnu bedre i fremtiden.\n"
    }
    
    , 
    {
        "url": "/tools/javascript/",
        "title": "javascript",
        "content": ""
    }
    
    , 
    {
        "url": "/kunder/",
        "title": "Kunder",
        "content": " Jeg giver Kiils mine varmeste anbefalinger\n– Per Asmussen\n "
    }
    
    , 
    {
        "url": "/cm/nlr/",
        "title": "nlr",
        "content": ""
    }
    
    , 
    {
        "url": "/erfaringer/frontend/ingrediens-omregner/",
        "title": "Omregner til ingredienser",
        "content": "Hovedsageligt kopieret fra: https://codepen.io/jacobbanner/pen/oxeoqp\nOmregner til ingredienser          =\n       .omregner-wrapper { margin: 2rem; } .omregner-wrapper::after { display: block; content: \"\"; clear: both; } .converter-wrapper { margin: 0 auto; width: 100%; max-width: 600px; text-align: center; padding: 10px; box-sizing: border-box; } .converter-wrapper input { font-size: 1em; width: 100%; text-align: center; margin-top: 10px; height: 40px; box-sizing: border-box; } .converter-wrapper span { position: relative; display: inline-block; vertical-align: middle; width: 100%; } .converter-wrapper span select { background-color: #263648; color: #fff; font-size: inherit; padding: 10px; width: 100%; border: 0; margin: 0; border-radius: 0px; text-indent: 0.01px; text-overflow: ''; -webkit-appearance: none; } .converter-wrapper span::before, .converter-wrapper span::after { content: \"\"; position: absolute; pointer-events: none; } .converter-wrapper span::after { content: \"\\25BC\"; height: 1em; font-size: .625em; line-height: 1; right: 1.5em; top: 50%; margin-top: -.5em; color: white; } .converter-wrapper span::before { width: 2.5em; right: 0; top: 0; bottom: 0; border-radius: 0; background-color: dimgray; } .converter-side-a, .converter-side-b { float: left; margin-top: 10px; box-sizing: border-box; width: 45%; } .converter-equals { float: left; box-sizing: border-box; width: 10%; font-size: 3rem; text-align: center; } .converter-equals p { line-height: 0.3; } .converter-side-a { padding-right: 10px; } .converter-side-b { padding-left: 10px; }   // // --- JAVASCRIPT UNIT CONVERTER // If you study this file, you'll see that all the important data (namely, unit names and conversion factors) are explicitly defined as JavaScript arrays under the \"Global Variable \u0026 Data Definitions\" heading (which should be right under these comments). // This is done, because: a) I figured it's the fastest way to do it, and b) it keeps everything in one file, making local storage and usage a snap. // If you wanna mess with these array definitions, keep in mind the following (better study the definitions first before you read this; otherwise skip it altogether): // 1) The unit[i][j] and factor[i][j] arrays should have the same j-length and their elements should correspond to each other in the j dimension; i.e. unit[0][2] should define the name and factor[0][2] the conversion factor of the SAME unit. Duh!... // 2) In every property (i.e. the i-dimension of the unit and factor arrays) there should be defined a 'primary' or 'base' unit, i.e. one with a conversion factor of 1. The definitions of the other (secondary) units should use this formula: // 1 [Secondary unit] = [Secondary unit conversion factor] [Primary Unit] // ^ // This goes in the factor array ___| // // e.g.: 1 ft = 0.3048 m // ==================================== // Global Variable \u0026 Data Definitions // ==================================== var property = new Array(); var unit = new Array(); var factor = new Array(); property[0] = \"Havregryn\"; unit[0] = new Array(\"spsk\", \"tsk\", \"ml\", \"dl\", \"gram\"); factor[0] = new Array(1, 0.333333333333333333, 0.06666666666666666666, 6.6666666666666666, 0.2); property[1] = \"Hvedemel\"; unit[1] = new Array(\"spsk\", \"tsk\", \"ml\", \"dl\", \"gram\"); factor[1] = new Array(1, 0.333333333333333333, 0.06666666666666666666, 6.6666666666666666, 0.1111111111111111111111); property[2] = \"Kartoffelmel\"; unit[2] = new Array(\"spsk\", \"tsk\", \"ml\", \"dl\", \"gram\"); factor[2] = new Array(1, 0.333333333333333333, 0.06666666666666666666, 6.6666666666666666, 0.08333333333333333333); // =========== // Functions // =========== function UpdateUnitMenu(propMenu, unitMenu) { // Updates the units displayed in the unitMenu according to the selection of property in the propMenu. var i; i = propMenu.selectedIndex; FillMenuWithArray(unitMenu, unit[i]); } function FillMenuWithArray(myMenu, myArray) { // Fills the options of myMenu with the elements of myArray. // !CAUTION!: It replaces the elements, so old ones will be deleted. var i; myMenu.length = myArray.length; for (i = 0; i = 35 \u0026\u0026 key = 48 \u0026\u0026 key = 96 \u0026\u0026 key "
    }
    
    , 
    {
        "url": "/kunder/per-asmussen/",
        "title": "Per Asmussen",
        "content": "Per Asmussen siger:\n I forbindelse med etableringen af mit madmedie www.gastrofun.dk var jeg i dialog med flere digitale udviklingshuse, men efter en god snak med Lennart fra Kiils var jeg aldrig i tvivl om at han skulle være min samarbejdspartner hele vejen igennem – fra konceptudvikling, hjemmesideopbygning, indholdsstrategi, tekniske krav samt det visuelle udtryk.\n Forståelsen for hvad det vil sige at gøre mediet brugervenligt både for læserne og brugerne var helt i top og en masse god sparring og feedback har givet mig et fremtidssikret og stærkt medie.\nProcessen fra ide til et færdigt medie var imponerende hurtig og siden var sågar udgivet 14 dage før lovet, hvilket var helt perfekt.\nTre måneder efter siden var i luften, fik jeg et SEO-bureau til at vurdere siden på nærmest alle parametre og siden fik en gennemsnitskarakter på 9 (på en 1-10 skala) og især sidens hurtighed og taksonomi-opbygning har imponeret mig.\nMediet har brug for konstant tilpasning og Kiils hurtige rettelser og justeringer er lige det jeg har brug for i en travl hverdag.\nJeg giver Kiils mine varmeste anbefalinger.\n"
    }
    
    , 
    {
        "url": "/emner/widgets/",
        "title": "widgets",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/brugervenlighed/",
        "title": "brugervenlighed",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/journalistik/",
        "title": "journalistik",
        "content": ""
    }
    
    , 
    {
        "url": "/tools/markdown/",
        "title": "markdown",
        "content": ""
    }
    
    , 
    {
        "url": "/erfaringer/journalistik/mellemrubrikker-indholdsoversigt/",
        "title": "Mellemrubrikker som indholdsoversigt",
        "content": "Da jeg for nylig udvidede min profilside på FOLKETS, som du kan finde her: Lennart Kiil , lavede jeg en indholdsoversigt baseret på mellemrubrikkerne i teksten.\nDet viste sig hurtigt at Google i søgeresultatet tog højde for dette ved at linke direkte til nogle af de mellemrubrikker som jeg havde angivet i indholdsoversigten og i selve mellemrubrikkerne med id.\nIndholdsoversigten er teknisk set en uordnet liste.\nSå\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#journalistisk-deklaration\u0026#34;\u0026gt;Journalistisk deklaration\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; linker til længere nede\n\u0026lt;h2 id=\u0026#34;journalistisk-deklaration\u0026#34;\u0026gt;Journalistisk deklaration\u0026lt;/h2\u0026gt; "
    }
    
    , 
    {
        "url": "/erfaringer/frontend/jquery-javascript/",
        "title": "jQuery - væk med paranteser i tekst",
        "content": "\u0026lt;script src=\u0026#34;https://code.jquery.com/jquery-2.2.4.min.js\u0026#34; integrity=\u0026#34;sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function stripParenthesis( node ) { if(node.length) { node.contents().each(function(index, child) { if( child.nodeType === 3 ) { child.nodeValue = child.nodeValue.replace(/\\(|\\)/g, \u0026#39;\u0026#39;); } else { stripParenthesis( $(child) ); } }); } } jQuery(document).ready(function($) { stripParenthesis( $(\u0026#39;a:contains(\u0026#34;Opskriftsgruppe\u0026#34;)\u0026#39;).closest( \u0026#34;span\u0026#34; ) ); $(\u0026#39;a:contains(\u0026#34;Opskriftsgruppe\u0026#34;)\u0026#39;).css(\u0026#39;display\u0026#39;, \u0026#39;none\u0026#39;); $(\u0026#39;a:contains(\u0026#34;Opskriftsgruppe\u0026#34;)\u0026#39;).closest( \u0026#34;span\u0026#34; ).css({ \u0026#34;font-size\u0026#34;: \u0026#34;21px\u0026#34;, \u0026#34;line-height\u0026#34;: \u0026#34;3\u0026#34; }); }); \u0026lt;/script\u0026gt; "
    }
    
    , 
    {
        "url": "/emner/ankertekst/",
        "title": "ankertekst",
        "content": ""
    }
    
    , 
    {
        "url": "/erfaringer/seo/hvad-betyder-ankertekst/",
        "title": "Hvad betyder ankertekst?",
        "content": "Gider du linke til min profil-side på FOLKETS med Lennart Kiil i ankerteksten?\nSpurgte jeg i dag.\nPersonen, jeg spurgte, var så venlig at linke med Lennart Kiil netop i ankerteksten. Han havde linket mit navn til min profil og dermed gjort præcist som jeg havde håbet på han ville.\n\u0026ldquo;Men hvad betyder ankertekst, bare så jeg lærer lidt her?\u0026rdquo;\nSpurgte han så.\nIfølge Wikipedia er ankerteksten:\n The anchor text, link label, link text, or link title is the visible, clickable text in a hyperlink.\n Oversat til dansk betyder det vel noget i retning af:\n\u0026ldquo;Ankerteksten er den synlige, klikbare del af et hyperlink.\u0026rdquo;\nEksempelvis sådan her:\nSe profilen for \u0026lt;a href=\u0026#34;https://www.folkets.dk/brugere/lennart-kiil\u0026#34;\u0026gt;Lennart Kiil\u0026lt;/a\u0026gt; for at lære mere om ham. Som bliver til:\nSe profilen for Lennart Kiil for at lære mere om ham.\nDe fleste er enige om at ankerteksten har betydning i SEO-sammenhæng for ranking i Googles søgemaskine.\nMit håb er netop også at jeg kan generobre førstepladsen på Google for mit eget navn, en plads jeg har måttet - midlertidigt forhåbentligt - overlade til Berlingske.\n"
    }
    
    , 
    {
        "url": "/emner/linkbuilding/",
        "title": "linkbuilding",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/ranking/",
        "title": "ranking",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/seo/",
        "title": "SEO",
        "content": ""
    }
    
    , 
    {
        "url": "/tools/perl/",
        "title": "perl",
        "content": ""
    }
    
    , 
    {
        "url": "/erfaringer/tips-tricks/sorter-markdown-efter-overskrifter/",
        "title": "Sorter markdown dokument",
        "content": "Sorter sektioner i markdown. For eksempel efter #\nSorter # b mellemrubrik efter # a mellemrubrik.\n#B a content of B #A b content of A til\n#A b content of A #B a content of B I terminal med\nperl -0777 -ne \u0026#39; (undef,@paragraphs) = split /^#(?=[^#])/m; print map {\u0026#34;#$_\u0026#34;} sort @paragraphs; \u0026#39; file.md For yderligere info se også svar her "
    }
    
    , 
    {
        "url": "/emner/sortering/",
        "title": "sortering",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/struktur/",
        "title": "struktur",
        "content": ""
    }
    
    , 
    {
        "url": "/tools/terminal/",
        "title": "terminal",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/tips/",
        "title": "tips",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/tricks/",
        "title": "tricks",
        "content": ""
    }
    
    , 
    {
        "url": "/erfaringer/tips-tricks/bevar-whitespace-output/",
        "title": "Bevar whitespace i output med &nbsp;",
        "content": "Nogle gange her man bare brug for noget plads i et dokument.\nNon-breaking space – \u0026amp;nbsp; – er ikke bare non-breaking, den er også \u0026lsquo;non-collapsing\u0026rsquo;.\nSom du kan læse på wikipedia :\n Non-collapsing behavior A second common application of non-breaking spaces is in plain text file formats such as SGML, HTML, TeX and LaTeX, whose rendering engines are programmed to treat sequences of whitespace characters (space, newline, tab, form feed, etc.) as if they were a single character (but this behavior can be overridden). Such \u0026ldquo;collapsing\u0026rdquo; of whitespace allows the author to neatly arrange the source text using line breaks, indentation and other forms of spacing without affecting the final typeset result.\n  In contrast, non-breaking spaces are not merged with neighboring whitespace characters when displayed, and can therefore be used by an author to simply insert additional visible space in the resulting output without using spans styled with peculiar values of the CSS “white-space” property. Conversely, indiscriminate use (see the recommended use in style guides), in addition to a normal space, gives extraneous space in the output.\n Derfor kan \u0026amp;nbsp; bruges til at bevare whitespace, altså tomrum - herunder blanke linjer, i html-output i browsere, pdf-output i dokumenter og så videre, når kilden er en tekst-fil, markdown eller anden \u0026lsquo;ren tekst\u0026rsquo;-baseret fil.\nEksempler:\nText Text giver\n Text\nText\n Mens\nText \u0026amp;nbsp; \u0026amp;nbsp; Text giver\n Text\n  Text\n "
    }
    
    , 
    {
        "url": "/tools/bootstrap-4/",
        "title": "bootstrap-4",
        "content": ""
    }
    
    , 
    {
        "url": "/tools/drupal-8/",
        "title": "Drupal 8",
        "content": ""
    }
    
    , 
    {
        "url": "/cm/feed/",
        "title": "feed",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/frontend/",
        "title": "frontend",
        "content": ""
    }
    
    , 
    {
        "url": "/tools/pantheon/",
        "title": "pantheon",
        "content": ""
    }
    
    , 
    {
        "url": "/erfaringer/frontend/klimaleksikon-tachyons-performance/",
        "title": "Sådan fik jeg perfekte 100 i mobilhastighed",
        "content": "Med en static site generator er det efterhånden relativt nemt at bygge et site som er optimeret på ydelse.\nMen hvis nu man skal bygge noget mere kompliceret hvor man har brug for et CMS. Hvad så? Kan man stadig komme helt i top med performance i frontend med et CMS?\nJa! Heldigvis da.\nKlimaleksikon, Danmarks bedste sted at blive klog på klima , er bygget med Drupal 8. Tidligere brugte jeg Bootstrap 4 i frontend. Nu har jeg skiftet til Tachyons.\nSitet er hosted på Pantheon. Og de arbejder sammen med Fastly omkring CDN.\nAllerede med Bootstrap 4 klarede Klimaleksikon sig flot i Chromes test for ydelse i mobil. Med resultater i de helt høje 90'ere.\nMen jeg udskiftede Bootstrap 4 med Tachyons. Og nu er det lykkedes mig at få det bedst mulige resultat på 100 i mobil-testen.\nOg resultatet er vel at mærke opnået med den hårde indstilling: \u0026ldquo;Applied Fast 3G, 4x CPU Slowdown\u0026rdquo;\nDet skal siges at det er på sider uden billeder. På sider med billeder, som for eksempel forsiden, får jeg \u0026ldquo;kun\u0026rdquo; 99 som resultat.\nMen alt i alt yderst tilfredstillende resultater. Som du naturligvis selv kan efterprøve hvis du har Chrome som browser.\nKonklusion:\nKombinationen Pantheon, Drupal 8 og Tachyons kan bestemt anbefales hvis du vil have et hurtigt site.\n"
    }
    
    , 
    {
        "url": "/tools/tachyons/",
        "title": "tachyons",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/ydelse/",
        "title": "Ydelse",
        "content": "Ydelse, på engelsk performance, er en meget væsentlig parameter i næsten alle digitale produkter.\n"
    }
    
    , 
    {
        "url": "/erfaringer/frontend/hastighed-uden-bannere/",
        "title": "FOLKETS meget hurtigere efter drop af bannere",
        "content": "For lidt over to uger siden droppede jeg bannere helt på FOLKETS.\nDe første resultater viste at det gav betydeligt hurtigere sider til brugerne.\nNu er der data nok til at konkludere noget mere håndfast i forhold til hastighed. Og til at se nærmere på de forskelige enheder:\nIkke overraskende er de største forbedringer der hvor der før var flest bannere. En halvering af tiden det tager at loade på tablet og laptop/desktop.\nPå mobil var der færre bannere og her er effekten mindre. En forbedring på knap 10 procent.\nMobil er også mere afhængig af ting som jeg ikke har indflydelse på såsom folks mobile dækning. Hvis folk sidder i toget eller andre steder med dårlig dækning, så kan ens site være nok så optimeret - så vil det stadig gå langsomt for brugeren.\nOg det afspejler sig i at det er svært at få gennemsnitstiderne lige så langt ned som for enheder der er på mere stabile netværk.\nAltså, en forbedring i snit på knap 10 procent på mobil. Betyder det så at ændringen har været omsonst for mobil?\nNej, man skal ikke lade sig snyde af gennemsnittet som især på mobil kan påvirkes af outliers, når folk sidder med en dårlig mobil forbindelse, og det tager måske 20 sekunder at hente en side. Det sker næppe ofte på tablets på wifi eller desktops på kablede forbindelser.\nOg hvis vi ser på intervaller i stedet for gennemsnit, så er der en klar forbedring - også for mobil:\nLæg mærke til at uanset om vi ser på mobil eller tablet / desktop, så er der nu langt, langt flere end før i de gode, hurtige intervaller og langt, langt færre i de dårlige, langsomme intervaller.\nEksempelvis er der efter at jeg droppede bannere mange flere i intervallet 0-1 sekunder og i intervallet 1-3 sekunder. Og meget færre i intervallet 7-13 sekunder. På tværs af enheder.\nDet vil sige at hvadenten vi ser på mobil eller desktop, så er der nu langt færre end før som oplever FOLKETS som langsomt.\nHvis vi alene ser på hastighed og den brugeroplevelse der ligger i forbindelse hermed, så har valget om at fjerne bannere været en ubetinget succes på tværs af alle enhedstyper.\nSenere vil jeg se på hvad det har betydet for andre faktorer såsom tid brugt på sitet, afvisningsrate og konvertering.\n"
    }
    
    , 
    {
        "url": "/tools/google-analytics/",
        "title": "google-analytics",
        "content": ""
    }
    
    , 
    {
        "url": "/erfaringer/seo/lovende-ctr-google-discover/",
        "title": "Lovende Google Discover klikrate (CTR)",
        "content": "Torsdag den 30. april 2019 dukkede en side fra FOLKETS for føste gang op i Googles Discover.\nSiden da er det sket nogle gange:\n   Kliks Visninger CTR1     154 ~ 1400 11%    Google Discover er en slags personligt feed baseret på Googles søgemaskine kombineret med kunstig intelligens som kan give personlige resultater.\nGoogles Discover funktion er tilgængelig på mobile Android-enheder. Discover kan tilgås med selve Google-appen.\nSet fra en udgivers synspunkt ser Google Discover interessant ud da klikraten umiddelbart er meget høj:\nPå billedet ses det også at man nu for nogle sites i Search Console kan få oplysninger om visninger og kliks fra Google Discover. Det tyder på at Google satser en del på det her.\nAntallet af kliks fra Google Discover er samlet set stadigt meget lavt, men mon ikke det kommer til at stige hvis for eksempel at Google Discover kobles mere sammen med Googles Assistent, for eksempel.\n  Click-through rate, på dansk klikrate - sommetider benævnt klikfrekvens. Andelen af kliks per 100 visninger. \u0026#x21a9;\u0026#xfe0e;\n   "
    }
    
    , 
    {
        "url": "/cases/climate-encyclopedia/",
        "title": "Climate Encyclopedia",
        "content": "Climate Encyclopedia er den engelske udgave af Klimaleksikon.dk\n"
    }
    
    , 
    {
        "url": "/erfaringer/frontend/bootstrap-4/",
        "title": "Det nemmeste CSS framework",
        "content": "Bootstrap 4 er næppe det nemmeste og hurtigste at prototype i længere. Og lidt for tungt hvis man virkelig går op i hastighed også på langsommere mobilforbindelser.\n"
    }
    
    , 
    {
        "url": "/erfaringer/seo/google-tidlig-indsats/",
        "title": "Google belønner tidlig indsats",
        "content": "Små medier kan markere sig ved at være først med på internationale navne. Og det er tilsyneladende også noget som giver bonus i søgeresultaterne.\nFor ikke så længe tid siden skrev jeg et indlæg her på Kiils med titlen: Når de små medier overhaler de store :\n De små medier er generelt mere manøvredygtige end de store. Det gælder også på indholdsstrategien.\nDet betyder at små medier kan reagere hurtigt på internationale trends.\nEt eksempel på dette er at Folkets Avis har skrevet meget om Jordan Peterson . Det har de store danske medier ikke, på trods af at han er en meget omtalt mand i den internationale presse.\n Folkets Avis var altså tidligt ude og markere sig med indhold om Jordan Peterson, som ikke var blevet opdaget af den øvrige danske presse endnu på det tidspunkt.\nI dag har flere medier så skrevet om manden.\nMen den indsats, Folkets Avis gjorde, gav ikke bare trafik dengang. Noget tyder på at en tidlig og relativ omfattende indsats belønnes af Googles søgemaskinealgoritme.\nSe her:\nDet er en flot placering. Om det bliver muligt at holde den, vil tiden vise.\nMen det er i hvert fald rart at se at det betaler sig at gøre en grundig og tidlig indsats.\n"
    }
    
    , 
    {
        "url": "/emner/indholdsstrategi/",
        "title": "indholdsstrategi",
        "content": ""
    }
    
    , 
    {
        "url": "/erfaringer/indhold/om-oplevelser-og-langsigtet-indholdsstrategi/",
        "title": "Om oplevelser og langsigtet indholdsstrategi",
        "content": "Præmisserne på internettet ændrer sig hele tiden.\nKan det så overhovedet betale sig at tænke langsigtet?\nJa!\nDet er faktisk noget nær nødvendigt. Ikke mindst hvis du har planer om at hente trafik fra søgemaskiner som tillægger \u0026ldquo;historik\u0026rdquo; en stor betydning.\nOg det gør for eksempel Googles søgemaskine i min erfaring.\n(Jeg har Klimaleksikon.dk med hele ti år på nettet i næsten uforandret form at bygge den påstand på, men det vil jeg skrive om i et andet indlæg.)\nHvis du engang i fremtiden vil klare dig godt på et bestemt søgeord, er det en god idé allerede nu at gå igang med at bygge fundamentet.\nPå Folkets Avis har jeg lavet muligheden for at man kan lave publikationer, som får sin egen plads på avisen.\nHver publikation kan være redaktionelt og økonomisk uafhængig af Folkets Avis og kan i princippet endda udgives på et separat domæne.\nDen første publikation, jeg har lavet, er et magasin kaldet \u0026lt;em\u0026gt;Oplevelser\u0026lt;/em\u0026gt; . På Folkets Avis fylder politik ret meget. Så er det rart at blive mindet om at livet også er andet end det.\nIdeen er altså dels nu og her at skabe godt indhold som supplerer den redaktionelle linje og samtidig på længere sigt at rykke frem i Google på ordet \u0026lsquo;oplevelser\u0026rsquo;.\nMåske er online publikationer og magasiner i det hele taget en god måde at opbygge digital tilstedeværelse på. Og man behøver ikke nødvendigvis et domæne til hver af dem.\n"
    }
    
    , 
    {
        "url": "/erfaringer/abo/salg/",
        "title": "risikoen for at abonnenter forsvinder med denne teknik er desværre stor",
        "content": "Tidligere telefonmand skrev til mig med godt råd – lige efter kampagnen var gået i luften.\nMan kan ikke tage højde for alt selv. Og nogle gange prøver man noget af uden at have tænkt alle konsekvenser helt igennem.\nOg i forhold til abonnementsmodellen bør man nok altid overveje et eventuelt tiltags effekt ikke bare på konverteringsraten, men også på frafaldsraten.\nOg blot få minutter efter jeg i dag havde lovet en signeret madbog af Knud Damgaard til nye privat- og supersponsorer på Folkets Avis tikkede følgende besked ind:\n Du laver en klassisk fejl med at belønne nye abonnenter med din bog, hvor nogle af de gamle abonnenter så vil føle sig forfordelt. Jeg er personligt ligeglad, men risikoen for at abonnenter forsvinder med denne teknik er desværre stor. Jeg så det specielt, da jeg arbejdede i telebranchen omkring årtusindskiftet. Folk skiftede teleselskab oftere end de skiftede underbukser, fordi teleselskaberne lokkede nye kunder til og belønnede ikke dem der blev. Det er heldigvis skiftet nu. Pas på ikke at falde i den samme fælde. Dette er skrevet i kærlighed til Folkets Avis og dit arbejde.\n Det kunne jeg jo egentligt godt se at han havde ret i.\nMen han var ikke færdig endnu.\nHan skrev videre:\n En alternativ mulighed er næste gang at benytte de ting du har til rådighed som belønning i en konkurrence, hvor du udtrækker blandt alle dine abonnenter/sponsorer.\n Og det vil jeg så gøre snart.\nFor man skal behandle sine abonnenter godt. Simpelthen vise at man husker på dem man har – og ikke kun er opmærksom på at få nye ind.\nMan bliver en bedre forretningsmand af at lytte til andres råd.\nOg et bedre menneske.\n"
    }
    
    , 
    {
        "url": "/erfaringer/muren/redning/",
        "title": "En redningsplan for Folkets Avis – sådan tilpasser jeg mig for at overleve",
        "content": "Folkets Avis er enestående i den forstand at mediet i modsætning til den øvrige danske presse fungerer helt uden mediestøtte.\nDet gør at den er skarpere end de andre medier i sin kritik af systemet og politikerne. Og det er godt for demokratiet.\nMen det skal heller ikke være nogen hemmelighed at det er lidt af en udfordring at få sådan en størrelse til at løbe rundt og give overskud.\nIkke desto mindre havde jeg held med det. Og i en periode var udviklingen endog meget positiv.\nMen så ændrede Facebook på sin algoritme.\nHelt andre præmisser Facebook ændrede kort sagt på sine algoritmer, og det halverede trafikken til Folkets Avis .\nNår trafikken halveres, så halveres også antallet af abonnenter som sitet kan oppebære . Det er simpel matematik.\nÆndringen i Facebooks algoritmer betød således at antallet af betalende brugere på Folkets Avis begyndte at falde i stedet for at stige. Og det er ikke en holdbar udvikling i længden.\nNår præmisserne på den måde radikalt forandrer sig, så må man tilpasse sig. Eller opgive. Eller søge mediestøtten som de andre.\nMen for mig er mediestøtten ikke en mulighed, jeg vil benytte mig af til Folkets Avis. Så ville den blive lige så ligegyldig og systembevarende som de andre medier i Danmark.\nHeldigvis er der andre veje frem!\nFremover vil jeg fokusere mindre på de sociale medier og mere på at skabe værdi for læsere og virksomheder inde på FOLKETS.DK som nu er en udgiverplatform med plads til brands.\nFolkets Avis er altså ikke længere alene på FOLKETS.DK.\nFolkets Avis er stadig flagskibet på FOLKETS.DK - men der er også andre medier på platformen. Og plads til brands og produkter!\nMan kan sige at Folkets Avis i den forstand er blevet til et brand på FOLKETS.DK\nEt andet brand på FOLKETS.DK er mit magasin om det gode i livet: Oplevelser .\nFolkets Avis vil nok altid have lidt en særstilling i mine øjne. Folkets Avis har opbygget FOLKETS.DK.\nMen nu bliver der også plads til Folkets TV. Og meget, meget mere.\nDet er Folkets Avis der har bygget FOLKETS.DK op. Men nu kommer andre brands og medier til og understøtter det arbejde.\nSåledes klarer FOLKETS.DK sig allerede nu rigtigt fint på en række søgeord som ikke kun har relevans for Folkets Avis (omend det er Folkets Avis\u0026rsquo; fortjeneste), men også for andre brands som er på eller kunne tænkes at komme til på FOLKETS.DK.\nSamtidig vil de nye medier og brands på FOLKETS.DK bidrage yderligt til opbygningen af både forside og landingssider. Det er synergi-effekten i praksis.\nOg den slags skal der til hvis kampen skal tages bare en lille smule op imod de amerikanske medie-giganter ;)\nLad os tage landingssider som eksempel på hvordan synergi-effekten kan tage sig ud i praksis:\nLandingssider på FOLKETS.DK fungerer på tværs af de enkelte brands, og det giver en række fordele for alle parter. Hver publikation og hvert brand kan udgive på de fælles landingssider for personer og organisationer.\nFor eksempel ville et forlag kunne omtale en bog på siden for Jordan Peterson .\nEn landingsside der får en del specifik trafik. Det vil sige at de brugere som kommer ind på siden i forvejen har en interesse for emnet. Så har man et produkt, som knytter sig til den person, så er det her man skal ud med det.\nOgså forsiden er tilgængelig for alle brands og medier på platformen - når bestemte betingelser er opfyldt.\nForsiden giver plads til de bedste og mest interessante indlæg fra hver af udgivelserne og også til brands som vil kunne nyde godt af en forøget trafik og bedre placering i søgeresultaterne på Google.\nEndelig kan hver enkelt bruger på FOLKETS.DK opbygge sin egen nyhedsstrøm og følge relevante brands og medier.\nMikromedier og rapid prototyping Hele denne model giver også plads til rapid prototyping - altså det at man prøver af om noget virker. Man har allerede et publikum til rådighed og værktøjer til sammenligning med andre medier og brands.\nPå den måde kommer alt det, som er bygget op på FOLKETS.DK i forbindelse med udviklingen af Folkets Avis, mange flere til gode.\nOg uanset om det er noget omkring ens brand eller ens udgivelse, man vil have afprøvet, så kan det lade sig gøre. Lykkes eksperimentet, kan man eventuelt køre en bredere kampagne.\nDet er værd at understrege de enkelte udgiveres autonomi.\nHvert brand på FOLKETS.DK kan have sin egen redaktør, sin egen redaktionelle linje, sit eget design (inden for visse rammer) og så fremdeles.\nDer er meget andet og sige om alt dette, men afslutningsvist vil jeg blot nævne én ting mere:\nForsiden og FOLKETS.DK bliver meget mere mangfoldig på den her måde. Så det ikke altsammen handler om politik. Og det gør livet jo heller ikke.\nOg den bliver mere levende og dynamisk.\nJeg er glad for at skabe mere rum til at det gode og rare i livet også får mere omtale og plads på nettet. Og til at de dygtige producenter i Danmark kan fortælle om de de skaber til gavn for os alle.\nOg så lover jeg ikke at glemme den systemkritiske journalistik som ligger mit hjerte nært. Det er nemlig den alt det andet kan være med til at give bedre økonomiske vilkår.\nGod dag derude og tak fordi du læste med!\nLennart Se også min video her:\n  "
    }
    
    , 
    {
        "url": "/emner/abonnementsmodellen/",
        "title": "Alt om Abonnementsmodellen",
        "content": " Abonnementsmodellen forbindes på engelsk ofte med SaaS, men den rette term er snarere subscription model  "
    }
    
    , 
    {
        "url": "/cm/featured/",
        "title": "Featured",
        "content": ""
    }
    
    , 
    {
        "url": "/erfaringer/abo/abonnenter-nok/",
        "title": "Får jeg abonnenter nok til at leve af mit online-medie?",
        "content": "Sandsynligvis ikke. Men læs alligevel videre og få et simpelt værktøj til at vurdere dine chancer.\nAbonnementsmodellen for indhold er gammelkendt og har vist sit værd gennem tiden for magasiner og aviser.\nOg i dag har andre leverandører af indhold, for eksempel Netflix, stor succes med modellen. Også privatpersoner, som skaber indhold af forskellig art, har med hjælp fra services som Patroen haft glæde af modellen - nok oftest som supplement til anden indtægt.\nSelv har jeg erfaring med modellen fra det medie jeg har stiftet og opbygget: Folkets Avis .\nJeg kan nu leve af Folkets Avis. Det er en lille sejr i sig selv og forhåbentligt første skridt på vej mod flere succeser.\nMen hvad med dig?\nMange vil gerne starte et medie op eller på anden vis leve at at skabe indhold og sælge det online på et site man selv er ejer af.\nHvor meget skal der til? Inden man går i gang kan man med fordel gøre sig nogle overvejelser om hvad der skal til.\nDet handler om\n at få nogle læsere ind på sin side og sælge abonnementer til dem  Vi kan nu se nærmere på hvor mange læsere der skal til, hvor god man skal være til at overbevise dem om at købe et abonnement, og hvor dygtig man skal være til at fastholde sine kunder, når man først har fået dem ind som abonnenter.\nHver solgt abonnement er en \u0026ldquo;vundet\u0026rdquo; abonnent. Las os kalde antallet af vundne abonnenter for Va.\nDet antal abonnenter, som kan vindes inden for en given periode, er givet ved antal læsere, noteret som L, og den andel af læsere man får solgt et abonnement til. Denne andel kalder vi konverteringraten, noteret som K.\nFor en given periode er tilvæksten i antal abonnenter således givet ved:\n$ V_a = L \\cdot K $\nHvis der ikke er noget frafald så er det samlede antal abonnenter, noteret A, ganske enkelt lig antallet af abonnenter vundet over tid, altså Va.\nMen sådan er virkeligheden ikke. Abonnenter falder hele tiden fra og tabes konstant af mange forskellige årsager.\nDet antal abonnenter, som tabes over en given periode, kan vil kalde Ta for tabte abonnenter. Det kan udregnes som produktet af det samlede antal abonnenter, A, og den andel af disse abonnenter som tabes inden for en given periode. Denne andel kalder vi frafaldsraten, F.\n$ T_a = A \\cdot F $\nGivet et nogenlunde stabilt læsertal og stabile konverterings- og frafaldsrater, så vil mediet på et tidspunkt nå et plateau, eller et vækstloft om man vil, hvor antal af løbende vundne abonnenter er lig med antallet af løbende tabte abonnenter – og det samlede antal abonnenter vil da stagnere. En ligevægt er på plads:\n$ T_a = V_a $\nHvis vi i stedet indsætter komponenterne for Ta og Va, får vi:\n$ A \\cdot F = L \\cdot K $\nDet antal abonnenter, du vil kunne opnå med et givet antal læsere og en fastlagt konverterings- og frafaldsrate, kan altså forudsiges ud fra denne simple formel:\n$ A = \\frac{L \\cdot K}{F } $\nLad os tage et konkret eksempel med 100.000 månedlige læsere, en månedlig konverteringsrate på en halv promille og en månedlig frafaldsrate på fem procent.\n$ A = \\frac{100000 \\cdot 0{,}0005}{0{,}05} = 1000 $\nAltså kan du under de forudsætninger ikke forvente mere end maksimalt 1000 abonnenter.\nFå læsere - få abonnenter Hvis du i stedet kun har 10.000 læsere rammes vækstloftet allerede ved 100 opnåede abonnenter og så fremdeles.\nHvis dit medie er mere specialiseret, kan du måske øge konverteringsraten og sænke frafaldsraten, men så er det til gengæld også sværere at opnå det store antal læsere.\nOg husk på: Med tiden vil et større antal af læserne allerede være abonnenter og kan således ikke vindes. Og i takt med at antallet af abonnenter stiger vil det samlede antal abonnenter, der tabes, gøre det samme.\nDin vækst vil med andre ord flade asymptotisk ud, når antallet af abonnenter nærmer sig vækstloftet. Og så vil antallet ellers forblive omkring vækstloftet, med mindre du kan ændre markant på nogle af de nævnte faktorer.\nDu vil altså med stor sandsyblighed opleve at det bliver svært at opretholde vækst.\nOg du vil med næsten usvigelig sikkerhed ramme loftet. Og man kan nå dertil overraskende hurtigt.\nKan du leve af for eksempel 500 abonnenter - eller af 1000?\nDet kommer vel dels an på, hvor meget hver især betaler om måneden. Men prisen på abonnementet påvirker også antallet af abonnementer som kan sælges og dermed antallet af abonnenter som kan vindes og fastholdes.\nDet vender vil tilbage til.\n"
    }
    
    , 
    {
        "url": "/erfaringer/some/delinger-bonus-linkedin/",
        "title": "Delinger giver bonus på LinkedIn",
        "content": "Læg relevante links på LinkedIn og forøg antallet af besøg til din profilside mangefold.\nFor ganske nylig begyndte jeg via LinkedIn at dele links til min blog her på Kiils .\nI første omgang var hensigten at dele ud af de erfaringer, som opbygningen af et digitalt medie helt fra bunden, har givet mig. Og det er ikke så få!\nJeg har brugt fem år på at skabe Folkets Avis , og i det tidsrum har jeg faktisk kun sporadisk haft tid til at bruge LinkedIn.\nModtagelsen på LinkedIn efter fem års pause har været rigtig god. Se blot her:\nMin aktivitetsforøgelse på LinkedIn, hvor jeg på det allerseneste flittigt har delt relevante links med originalt indhold, er i den grad blevet belønnet.\nMåske er der i dag mere fokus på indhold på LinkedIn end der var for fem år siden, da jeg sidst brugte LinkedIn med jævne mellemrum.\nI hvert fald kan jeg konstatere at deling af relevant og originalt indhold som links på LinkedIn resulterer i en markant stigning i antallet af mennesker som tjekker ens profilside ud.\nKonklusion:\nHvis du gerne vil have flere mennesker til at besøge din profilside på LinkedIn, skal du bare dele godt og originalt indhold.\nOm sammenhængen også gælder i samme grad hvis du deler andres indhold, skal jeg ikke kunne sige.\n"
    }
    
    , 
    {
        "url": "/emner/linkedin/",
        "title": "Lidt om LinkedIn",
        "content": ""
    }
    
    , 
    {
        "url": "/emner/sociale-medier/",
        "title": "Sociale medier",
        "content": ""
    }
    
    , 
    {
        "url": "/erfaringer/trafik/kilder/",
        "title": "Sociale medier vigtige – men husk de andre trafikkilder",
        "content": "2017 var et rekordår for Folkets Avis på mange måder.\nSåledes var også de samlede antal sidevisninger højere end noget tidligere år.\nSer vi på anskaffelse skete der noget lidt overraskende. I hvert fald når man tager i betratning at antallet af fans på Folkets Avis Facebook side voksede pænt hen over året og nærmede sig 10.000 ved dets afslutning.\nFor på trods af stigningen faldt antallet af brugere som blev sendt til Folkets Avis fra de sociale medier, og med de sociale medier menes praktisk taget ene og alene Facebook.\nDenne udvikling passer fint med Facebooks ambitioner om at holde flere brugere inden for Facebooks egne rammer. Samtidig gør medier klogt i at finde andre trafikkilder og opdyrke et eget trofast publikum.\nOg måske endda tænke lidt i SEO-optimering.\nFolkets Avis oplevede således en stor stigning - næsten en fordobling - af forside trafik i 2017 i forhold il 2016. Det er godt.\nFlere kom også ind via søgninger på Google. Og web push notifikationer via Onesignal.\nEt område hvor Folkets Avis virkelig kan oppe sig er på email. Altså at få brugere ind gennem nyhedsbreve.\nUdviklingen på fem områder fra 2016 til 2017:\n"
    }
    
    , 
    {
        "url": "/erfaringer/indhold/overhaling/",
        "title": "Når de små medier overhaler de store",
        "content": "Den korte afstand mellem læser og redaktion er en fordel.\nDe små medier er generelt mere manøvredygtige end de store. Det gælder også på indholdsstrategien.\nDet betyder at små medier kan reagere hurtigt på internationale trends.\nEt eksempel på dette er at Folkets Avis har skrevet meget om Jordan Peterson. Det har de store danske medier ikke, på trods af at han er en meget omtalt mand i den internationale presse.\nArbejdsgangene er kortere - og afstanden mellem læsere og redaktion ligeså - på de små medier.\nOg nogle gange er det læserne der her fingeren på pulsen.\nFolkets Avis giver så læseren mulighed for at blive skribent. Og i tilfældet Jordan Peterson har det for alvor givet pote.\n"
    }
    
    , 
    {
        "url": "/brands/digitalt/",
        "title": "digitalt",
        "content": "For mig er der en ekstra tilfredsstillelse ved at arbejde på ting hvor jeg har været med fra starten til at lægge fundamentet. Og det var tilfældet med madsitet GastroFun.dk .\nSammen med Per Asmussen byggede jeg GastroFun.dk fra bunden. Vi har været gode til at finde de rigtige løsninger i forhold til indholdsstruktur og informationsarkitektur.\nSiden har allerede opnået en meget prominent placering i Googles søgemaskine hvilket har været et centralt succeskriterie.\nPer er meget ambitiøs med siden, og det passer mig godt. I dag er udvikling på nettet altid noget løbende fordi konkurrenterne hele tiden er i bevægelse.\nJeg er derfor fortsat med til at rådgive og løse konkrete udfordringer på GastroFun.dk så siden forhåbentligt kan klare sig endnu bedre i fremtiden.\n"
    }
    
    , 
    {
        "url": "/genrer/",
        "title": "Genrer",
        "content": ""
    }
    
    , 
    {
        "url": "/kontakt/",
        "title": "Kontakt",
        "content": "Du kan ringe på telefon 40261872 eller skrive en mail direkte til lennart@kiils.dk\nPostadresse:\nKiils v/Lennart Kiil Kirkeskov Allé 72 3050 Humlebæk\neller bruge kontaktformularen\nYour Name Email Address An email address is required.  Message   "
    }
    
    , 
    {
        "url": "/kunder/lars-vestergaard/",
        "title": "Lars Vestergaard",
        "content": "Kiils har længe arbejdet sammen med Lars Vestergaard som besidder en række kvaliteter på det menneskelige plan som er særdeles væsentlige i forhold til langvarigt samarbejde såsom loyalitet, pålidelighed og høj arbejdsetik.\nLars Vestergaard har især vist sin kunnen inden for salg og marketing via alle digitale kanaler, men også når det har været påkrævet inden for trafikoptimering og SEO.\nLars Vestergaard er ansvarlig og tilstedeværende og lever sig ind i sine klienters og kunders behov. Han har en iværksætters flid og ihærdighed kombineret med den professionelisme som er essentiel på den lange bane.\n"
    }
    
    , 
    {
        "url": "/brands/oplevelser/",
        "title": "Oplevelser",
        "content": "For mig er der en ekstra tilfredsstillelse ved at arbejde på ting hvor jeg har været med fra starten til at lægge fundamentet. Og det var tilfældet med madsitet GastroFun.dk .\nSammen med Per Asmussen byggede jeg GastroFun.dk fra bunden. Vi har været gode til at finde de rigtige løsninger i forhold til indholdsstruktur og informationsarkitektur.\nSiden har allerede opnået en meget prominent placering i Googles søgemaskine hvilket har været et centralt succeskriterie.\nPer er meget ambitiøs med siden, og det passer mig godt. I dag er udvikling på nettet altid noget løbende fordi konkurrenterne hele tiden er i bevægelse.\nJeg er derfor fortsat med til at rådgive og løse konkrete udfordringer på GastroFun.dk så siden forhåbentligt kan klare sig endnu bedre i fremtiden.\n"
    }
    
    , 
    {
        "url": "/priser/",
        "title": "Priser",
        "content": "Prisen er ens for offentlige institutioner, virksomheder og privatpersoner.\nKr. 800 i timen.\nDer afregnes kun i hele timer.\nPris eksklusiv moms.\n"
    }
    
    , 
    {
        "url": "/search/",
        "title": "Søgning",
        "content": " /** * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 2.3.8 * Copyright (C) 2019 Oliver Nightingale * @license MIT */ ;(function(){ /** * A convenience function for configuring and constructing * a new lunr Index. * * A lunr.Builder instance is created and the pipeline setup * with a trimmer, stop word filter and stemmer. * * This builder object is yielded to the configuration function * that is passed as a parameter, allowing the list of fields * and other builder parameters to be customised. * * All documents _must_ be added within the passed config function. * * @example * var idx = lunr(function () { * this.field('title') * this.field('body') * this.ref('id') * * documents.forEach(function (doc) { * this.add(doc) * }, this) * }) * * @see {@link lunr.Builder} * @see {@link lunr.Pipeline} * @see {@link lunr.trimmer} * @see {@link lunr.stopWordFilter} * @see {@link lunr.stemmer} * @namespace {function} lunr */ var lunr = function (config) { var builder = new lunr.Builder builder.pipeline.add( lunr.trimmer, lunr.stopWordFilter, lunr.stemmer ) builder.searchPipeline.add( lunr.stemmer ) config.call(builder, builder) return builder.build() } lunr.version = \"2.3.8\" /*! * lunr.utils * Copyright (C) 2019 Oliver Nightingale */ /** * A namespace containing utils for the rest of the lunr library * @namespace lunr.utils */ lunr.utils = {} /** * Print a warning message to the console. * * @param {String} message The message to be printed. * @memberOf lunr.utils * @function */ lunr.utils.warn = (function (global) { /* eslint-disable no-console */ return function (message) { if (global.console \u0026\u0026 console.warn) { console.warn(message) } } /* eslint-enable no-console */ })(this) /** * Convert an object to a string. * * In the case of `null` and `undefined` the function returns * the empty string, in all other cases the result of calling * `toString` on the passed object is returned. * * @param {Any} obj The object to convert to a string. * @return {String} string representation of the passed object. * @memberOf lunr.utils */ lunr.utils.asString = function (obj) { if (obj === void 0 || obj === null) { return \"\" } else { return obj.toString() } } /** * Clones an object. * * Will create a copy of an existing object such that any mutations * on the copy cannot affect the original. * * Only shallow objects are supported, passing a nested object to this * function will cause a TypeError. * * Objects with primitives, and arrays of primitives are supported. * * @param {Object} obj The object to clone. * @return {Object} a clone of the passed object. * @throws {TypeError} when a nested object is passed. * @memberOf Utils */ lunr.utils.clone = function (obj) { if (obj === null || obj === undefined) { return obj } var clone = Object.create(null), keys = Object.keys(obj) for (var i = 0; i 0) { var tokenMetadata = lunr.utils.clone(metadata) || {} tokenMetadata[\"position\"] = [sliceStart, sliceLength] tokenMetadata[\"index\"] = tokens.length tokens.push( new lunr.Token ( str.slice(sliceStart, sliceEnd), tokenMetadata ) ) } sliceStart = sliceEnd + 1 } } return tokens } /** * The separator used to split a string into tokens. Override this property to change the behaviour of * `lunr.tokenizer` behaviour when tokenizing strings. By default this splits on whitespace and hyphens. * * @static * @see lunr.tokenizer */ lunr.tokenizer.separator = /[\\s\\-]+/ /*! * lunr.Pipeline * Copyright (C) 2019 Oliver Nightingale */ /** * lunr.Pipelines maintain an ordered list of functions to be applied to all * tokens in documents entering the search index and queries being ran against * the index. * * An instance of lunr.Index created with the lunr shortcut will contain a * pipeline with a stop word filter and an English language stemmer. Extra * functions can be added before or after either of these functions or these * default functions can be removed. * * When run the pipeline will call each function in turn, passing a token, the * index of that token in the original list of all tokens and finally a list of * all the original tokens. * * The output of functions in the pipeline will be passed to the next function * in the pipeline. To exclude a token from entering the index the function * should return undefined, the rest of the pipeline will not be called with * this token. * * For serialisation of pipelines to work, all functions used in an instance of * a pipeline should be registered with lunr.Pipeline. Registered functions can * then be loaded. If trying to load a serialised pipeline that uses functions * that are not registered an error will be thrown. * * If not planning on serialising the pipeline then registering pipeline functions * is not necessary. * * @constructor */ lunr.Pipeline = function () { this._stack = [] } lunr.Pipeline.registeredFunctions = Object.create(null) /** * A pipeline function maps lunr.Token to lunr.Token. A lunr.Token contains the token * string as well as all known metadata. A pipeline function can mutate the token string * or mutate (or add) metadata for a given token. * * A pipeline function can indicate that the passed token should be discarded by returning * null, undefined or an empty string. This token will not be passed to any downstream pipeline * functions and will not be added to the index. * * Multiple tokens can be returned by returning an array of tokens. Each token will be passed * to any downstream pipeline functions and all will returned tokens will be added to the index. * * Any number of pipeline functions may be chained together using a lunr.Pipeline. * * @interface lunr.PipelineFunction * @param {lunr.Token} token - A token from the document being processed. * @param {number} i - The index of this token in the complete list of tokens for this document/field. * @param {lunr.Token[]} tokens - All tokens for this document/field. * @returns {(?lunr.Token|lunr.Token[])} */ /** * Register a function with the pipeline. * * Functions that are used in the pipeline should be registered if the pipeline * needs to be serialised, or a serialised pipeline needs to be loaded. * * Registering a function does not add it to a pipeline, functions must still be * added to instances of the pipeline for them to be used when running a pipeline. * * @param {lunr.PipelineFunction} fn - The function to check for. * @param {String} label - The label to register this function with */ lunr.Pipeline.registerFunction = function (fn, label) { if (label in this.registeredFunctions) { lunr.utils.warn('Overwriting existing registered function: ' + label) } fn.label = label lunr.Pipeline.registeredFunctions[fn.label] = fn } /** * Warns if the function is not registered as a Pipeline function. * * @param {lunr.PipelineFunction} fn - The function to check for. * @private */ lunr.Pipeline.warnIfFunctionNotRegistered = function (fn) { var isRegistered = fn.label \u0026\u0026 (fn.label in this.registeredFunctions) if (!isRegistered) { lunr.utils.warn('Function is not registered with pipeline. This may cause problems when serialising the index.\\n', fn) } } /** * Loads a previously serialised pipeline. * * All functions to be loaded must already be registered with lunr.Pipeline. * If any function from the serialised data has not been registered then an * error will be thrown. * * @param {Object} serialised - The serialised pipeline to load. * @returns {lunr.Pipeline} */ lunr.Pipeline.load = function (serialised) { var pipeline = new lunr.Pipeline serialised.forEach(function (fnName) { var fn = lunr.Pipeline.registeredFunctions[fnName] if (fn) { pipeline.add(fn) } else { throw new Error('Cannot load unregistered function: ' + fnName) } }) return pipeline } /** * Adds new functions to the end of the pipeline. * * Logs a warning if the function has not been registered. * * @param {lunr.PipelineFunction[]} functions - Any number of functions to add to the pipeline. */ lunr.Pipeline.prototype.add = function () { var fns = Array.prototype.slice.call(arguments) fns.forEach(function (fn) { lunr.Pipeline.warnIfFunctionNotRegistered(fn) this._stack.push(fn) }, this) } /** * Adds a single function after a function that already exists in the * pipeline. * * Logs a warning if the function has not been registered. * * @param {lunr.PipelineFunction} existingFn - A function that already exists in the pipeline. * @param {lunr.PipelineFunction} newFn - The new function to add to the pipeline. */ lunr.Pipeline.prototype.after = function (existingFn, newFn) { lunr.Pipeline.warnIfFunctionNotRegistered(newFn) var pos = this._stack.indexOf(existingFn) if (pos == -1) { throw new Error('Cannot find existingFn') } pos = pos + 1 this._stack.splice(pos, 0, newFn) } /** * Adds a single function before a function that already exists in the * pipeline. * * Logs a warning if the function has not been registered. * * @param {lunr.PipelineFunction} existingFn - A function that already exists in the pipeline. * @param {lunr.PipelineFunction} newFn - The new function to add to the pipeline. */ lunr.Pipeline.prototype.before = function (existingFn, newFn) { lunr.Pipeline.warnIfFunctionNotRegistered(newFn) var pos = this._stack.indexOf(existingFn) if (pos == -1) { throw new Error('Cannot find existingFn') } this._stack.splice(pos, 0, newFn) } /** * Removes a function from the pipeline. * * @param {lunr.PipelineFunction} fn The function to remove from the pipeline. */ lunr.Pipeline.prototype.remove = function (fn) { var pos = this._stack.indexOf(fn) if (pos == -1) { return } this._stack.splice(pos, 1) } /** * Runs the current list of functions that make up the pipeline against the * passed tokens. * * @param {Array} tokens The tokens to run through the pipeline. * @returns {Array} */ lunr.Pipeline.prototype.run = function (tokens) { var stackLength = this._stack.length for (var i = 0; i 1) { if (pivotIndex index) { end = pivotPoint } if (pivotIndex == index) { break } sliceLength = end - start pivotPoint = start + Math.floor(sliceLength / 2) pivotIndex = this.elements[pivotPoint * 2] } if (pivotIndex == index) { return pivotPoint * 2 } if (pivotIndex  index) { return pivotPoint * 2 } if (pivotIndex bVal) { j += 2 } else if (aVal == bVal) { dotProduct += a[i + 1] * b[j + 1] i += 2 j += 2 } } return dotProduct } /** * Calculates the similarity between this vector and another vector. * * @param {lunr.Vector} otherVector - The other vector to calculate the * similarity with. * @returns {Number} */ lunr.Vector.prototype.similarity = function (otherVector) { return this.dot(otherVector) / this.magnitude() || 0 } /** * Converts the vector to an array of the elements within the vector. * * @returns {Number[]} */ lunr.Vector.prototype.toArray = function () { var output = new Array (this.elements.length / 2) for (var i = 1, j = 0; i 0 meq1 = \"^(\" + C + \")?\" + V + C + \"(\" + V + \")?$\", // [C]VC[V] is m=1 mgr1 = \"^(\" + C + \")?\" + V + C + V + C, // [C]VCVC... is m1 s_v = \"^(\" + C + \")?\" + v; // vowel in stem var re_mgr0 = new RegExp(mgr0); var re_mgr1 = new RegExp(mgr1); var re_meq1 = new RegExp(meq1); var re_s_v = new RegExp(s_v); var re_1a = /^(.+?)(ss|i)es$/; var re2_1a = /^(.+?)([^s])s$/; var re_1b = /^(.+?)eed$/; var re2_1b = /^(.+?)(ed|ing)$/; var re_1b_2 = /.$/; var re2_1b_2 = /(at|bl|iz)$/; var re3_1b_2 = new RegExp(\"([^aeiouylsz])\\\\1$\"); var re4_1b_2 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\"); var re_1c = /^(.+?[^aeiou])y$/; var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/; var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/; var re_4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/; var re2_4 = /^(.+?)(s|t)(ion)$/; var re_5 = /^(.+?)e$/; var re_5_1 = /ll$/; var re3_5 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\"); var porterStemmer = function porterStemmer(w) { var stem, suffix, firstch, re, re2, re3, re4; if (w.length cri, by - by, say - say) re = re_1c; if (re.test(w)) { var fp = re.exec(w); stem = fp[1]; w = stem + \"i\"; } // Step 2 re = re_2; if (re.test(w)) { var fp = re.exec(w); stem = fp[1]; suffix = fp[2]; re = re_mgr0; if (re.test(stem)) { w = stem + step2list[suffix]; } } // Step 3 re = re_3; if (re.test(w)) { var fp = re.exec(w); stem = fp[1]; suffix = fp[2]; re = re_mgr0; if (re.test(stem)) { w = stem + step3list[suffix]; } } // Step 4 re = re_4; re2 = re2_4; if (re.test(w)) { var fp = re.exec(w); stem = fp[1]; re = re_mgr1; if (re.test(stem)) { w = stem; } } else if (re2.test(w)) { var fp = re2.exec(w); stem = fp[1] + fp[2]; re2 = re_mgr1; if (re2.test(stem)) { w = stem; } } // Step 5 re = re_5; if (re.test(w)) { var fp = re.exec(w); stem = fp[1]; re = re_mgr1; re2 = re_meq1; re3 = re3_5; if (re.test(stem) || (re2.test(stem) \u0026\u0026 !(re3.test(stem)))) { w = stem; } } re = re_5_1; re2 = re_mgr1; if (re.test(w) \u0026\u0026 re2.test(w)) { re = re_1b_2; w = w.replace(re,\"\"); } // and turn initial Y back to y if (firstch == \"y\") { w = firstch.toLowerCase() + w.substr(1); } return w; }; return function (token) { return token.update(porterStemmer); } })(); lunr.Pipeline.registerFunction(lunr.stemmer, 'stemmer') /*! * lunr.stopWordFilter * Copyright (C) 2019 Oliver Nightingale */ /** * lunr.generateStopWordFilter builds a stopWordFilter function from the provided * list of stop words. * * The built in lunr.stopWordFilter is built using this generator and can be used * to generate custom stopWordFilters for applications or non English languages. * * @function * @param {Array} token The token to pass through the filter * @returns {lunr.PipelineFunction} * @see lunr.Pipeline * @see lunr.stopWordFilter */ lunr.generateStopWordFilter = function (stopWords) { var words = stopWords.reduce(function (memo, stopWord) { memo[stopWord] = stopWord return memo }, {}) return function (token) { if (token \u0026\u0026 words[token.toString()] !== token.toString()) return token } } /** * lunr.stopWordFilter is an English language stop word list filter, any words * contained in the list will not be passed through the filter. * * This is intended to be used in the Pipeline. If the token does not pass the * filter then undefined will be returned. * * @function * @implements {lunr.PipelineFunction} * @params {lunr.Token} token - A token to check for being a stop word. * @returns {lunr.Token} * @see {@link lunr.Pipeline} */ lunr.stopWordFilter = lunr.generateStopWordFilter([ 'a', 'able', 'about', 'across', 'after', 'all', 'almost', 'also', 'am', 'among', 'an', 'and', 'any', 'are', 'as', 'at', 'be', 'because', 'been', 'but', 'by', 'can', 'cannot', 'could', 'dear', 'did', 'do', 'does', 'either', 'else', 'ever', 'every', 'for', 'from', 'get', 'got', 'had', 'has', 'have', 'he', 'her', 'hers', 'him', 'his', 'how', 'however', 'i', 'if', 'in', 'into', 'is', 'it', 'its', 'just', 'least', 'let', 'like', 'likely', 'may', 'me', 'might', 'most', 'must', 'my', 'neither', 'no', 'nor', 'not', 'of', 'off', 'often', 'on', 'only', 'or', 'other', 'our', 'own', 'rather', 'said', 'say', 'says', 'she', 'should', 'since', 'so', 'some', 'than', 'that', 'the', 'their', 'them', 'then', 'there', 'these', 'they', 'this', 'tis', 'to', 'too', 'twas', 'us', 'wants', 'was', 'we', 'were', 'what', 'when', 'where', 'which', 'while', 'who', 'whom', 'why', 'will', 'with', 'would', 'yet', 'you', 'your' ]) lunr.Pipeline.registerFunction(lunr.stopWordFilter, 'stopWordFilter') /*! * lunr.trimmer * Copyright (C) 2019 Oliver Nightingale */ /** * lunr.trimmer is a pipeline function for trimming non word * characters from the beginning and end of tokens before they * enter the index. * * This implementation may not work correctly for non latin * characters and should either be removed or adapted for use * with languages with non-latin characters. * * @static * @implements {lunr.PipelineFunction} * @param {lunr.Token} token The token to pass through the filter * @returns {lunr.Token} * @see lunr.Pipeline */ lunr.trimmer = function (token) { return token.update(function (s) { return s.replace(/^\\W+/, '').replace(/\\W+$/, '') }) } lunr.Pipeline.registerFunction(lunr.trimmer, 'trimmer') /*! * lunr.TokenSet * Copyright (C) 2019 Oliver Nightingale */ /** * A token set is used to store the unique list of all tokens * within an index. Token sets are also used to represent an * incoming query to the index, this query token set and index * token set are then intersected to find which tokens to look * up in the inverted index. * * A token set can hold multiple tokens, as in the case of the * index token set, or it can hold a single token as in the * case of a simple query token set. * * Additionally token sets are used to perform wildcard matching. * Leading, contained and trailing wildcards are supported, and * from this edit distance matching can also be provided. * * Token sets are implemented as a minimal finite state automata, * where both common prefixes and suffixes are shared between tokens. * This helps to reduce the space used for storing the token set. * * @constructor */ lunr.TokenSet = function () { this.final = false this.edges = {} this.id = lunr.TokenSet._nextId lunr.TokenSet._nextId += 1 } /** * Keeps track of the next, auto increment, identifier to assign * to a new tokenSet. * * TokenSets require a unique identifier to be correctly minimised. * * @private */ lunr.TokenSet._nextId = 1 /** * Creates a TokenSet instance from the given sorted array of words. * * @param {String[]} arr - A sorted array of strings to create the set from. * @returns {lunr.TokenSet} * @throws Will throw an error if the input array is not sorted. */ lunr.TokenSet.fromArray = function (arr) { var builder = new lunr.TokenSet.Builder for (var i = 0, len = arr.length; i 0) { var char = frame.str.charAt(0), noEditNode if (char in frame.node.edges) { noEditNode = frame.node.edges[char] } else { noEditNode = new lunr.TokenSet frame.node.edges[char] = noEditNode } if (frame.str.length == 1) { noEditNode.final = true } stack.push({ node: noEditNode, editsRemaining: frame.editsRemaining, str: frame.str.slice(1) }) } if (frame.editsRemaining == 0) { continue } // insertion if (\"*\" in frame.node.edges) { var insertionNode = frame.node.edges[\"*\"] } else { var insertionNode = new lunr.TokenSet frame.node.edges[\"*\"] = insertionNode } if (frame.str.length == 0) { insertionNode.final = true } stack.push({ node: insertionNode, editsRemaining: frame.editsRemaining - 1, str: frame.str }) // deletion // can only do a deletion if we have enough edits remaining // and if there are characters left to delete in the string if (frame.str.length  1) { stack.push({ node: frame.node, editsRemaining: frame.editsRemaining - 1, str: frame.str.slice(1) }) } // deletion // just removing the last character from the str if (frame.str.length == 1) { frame.node.final = true } // substitution // can only do a substitution if we have enough edits remaining // and if there are characters left to substitute if (frame.str.length = 1) { if (\"*\" in frame.node.edges) { var substitutionNode = frame.node.edges[\"*\"] } else { var substitutionNode = new lunr.TokenSet frame.node.edges[\"*\"] = substitutionNode } if (frame.str.length == 1) { substitutionNode.final = true } stack.push({ node: substitutionNode, editsRemaining: frame.editsRemaining - 1, str: frame.str.slice(1) }) } // transposition // can only do a transposition if there are edits remaining // and there are enough characters to transpose if (frame.str.length  1) { var charA = frame.str.charAt(0), charB = frame.str.charAt(1), transposeNode if (charB in frame.node.edges) { transposeNode = frame.node.edges[charB] } else { transposeNode = new lunr.TokenSet frame.node.edges[charB] = transposeNode } if (frame.str.length == 1) { transposeNode.final = true } stack.push({ node: transposeNode, editsRemaining: frame.editsRemaining - 1, str: charA + frame.str.slice(2) }) } } return root } /** * Creates a TokenSet from a string. * * The string may contain one or more wildcard characters (*) * that will allow wildcard matching when intersecting with * another TokenSet. * * @param {string} str - The string to create a TokenSet from. * @returns {lunr.TokenSet} */ lunr.TokenSet.fromString = function (str) { var node = new lunr.TokenSet, root = node /* * Iterates through all characters within the passed string * appending a node for each character. * * When a wildcard character is found then a self * referencing edge is introduced to continually match * any number of any characters. */ for (var i = 0, len = str.length; i = downTo; i--) { var node = this.uncheckedNodes[i], childKey = node.child.toString() if (childKey in this.minimizedNodes) { node.parent.edges[node.char] = this.minimizedNodes[childKey] } else { // Cache the key for this node since // we know it can't change anymore node.child._str = childKey this.minimizedNodes[childKey] = node.child } this.uncheckedNodes.pop() } } /*! * lunr.Index * Copyright (C) 2019 Oliver Nightingale */ /** * An index contains the built index of all documents and provides a query interface * to the index. * * Usually instances of lunr.Index will not be created using this constructor, instead * lunr.Builder should be used to construct new indexes, or lunr.Index.load should be * used to load previously built and serialized indexes. * * @constructor * @param {Object} attrs - The attributes of the built search index. * @param {Object} attrs.invertedIndex - An index of term/field to document reference. * @param {Object} attrs.fieldVectors - Field vectors * @param {lunr.TokenSet} attrs.tokenSet - An set of all corpus tokens. * @param {string[]} attrs.fields - The names of indexed document fields. * @param {lunr.Pipeline} attrs.pipeline - The pipeline to use for search terms. */ lunr.Index = function (attrs) { this.invertedIndex = attrs.invertedIndex this.fieldVectors = attrs.fieldVectors this.tokenSet = attrs.tokenSet this.fields = attrs.fields this.pipeline = attrs.pipeline } /** * A result contains details of a document matching a search query. * @typedef {Object} lunr.Index~Result * @property {string} ref - The reference of the document this result represents. * @property {number} score - A number between 0 and 1 representing how similar this document is to the query. * @property {lunr.MatchData} matchData - Contains metadata about this match including which term(s) caused the match. */ /** * Although lunr provides the ability to create queries using lunr.Query, it also provides a simple * query language which itself is parsed into an instance of lunr.Query. * * For programmatically building queries it is advised to directly use lunr.Query, the query language * is best used for human entered text rather than program generated text. * * At its simplest queries can just be a single term, e.g. `hello`, multiple terms are also supported * and will be combined with OR, e.g `hello world` will match documents that contain either 'hello' * or 'world', though those that contain both will rank higher in the results. * * Wildcards can be included in terms to match one or more unspecified characters, these wildcards can * be inserted anywhere within the term, and more than one wildcard can exist in a single term. Adding * wildcards will increase the number of documents that will be found but can also have a negative * impact on query performance, especially with wildcards at the beginning of a term. * * Terms can be restricted to specific fields, e.g. `title:hello`, only documents with the term * hello in the title field will match this query. Using a field not present in the index will lead * to an error being thrown. * * Modifiers can also be added to terms, lunr supports edit distance and boost modifiers on terms. A term * boost will make documents matching that term score higher, e.g. `foo^5`. Edit distance is also supported * to provide fuzzy matching, e.g. 'hello~2' will match documents with hello with an edit distance of 2. * Avoid large values for edit distance to improve query performance. * * Each term also supports a presence modifier. By default a term's presence in document is optional, however * this can be changed to either required or prohibited. For a term's presence to be required in a document the * term should be prefixed with a '+', e.g. `+foo bar` is a search for documents that must contain 'foo' and * optionally contain 'bar'. Conversely a leading '-' sets the terms presence to prohibited, i.e. it must not * appear in a document, e.g. `-foo bar` is a search for documents that do not contain 'foo' but may contain 'bar'. * * To escape special characters the backslash character '\\' can be used, this allows searches to include * characters that would normally be considered modifiers, e.g. `foo\\~2` will search for a term \"foo~2\" instead * of attempting to apply a boost of 2 to the search term \"foo\". * * @typedef {string} lunr.Index~QueryString * @example Simple single term query * hello * @example Multiple term query * hello world * @example term scoped to a field * title:hello * @example term with a boost of 10 * hello^10 * @example term with an edit distance of 2 * hello~2 * @example terms with presence modifiers * -foo +bar baz */ /** * Performs a search against the index using lunr query syntax. * * Results will be returned sorted by their score, the most relevant results * will be returned first. For details on how the score is calculated, please see * the {@link https://lunrjs.com/guides/searching.html#scoring|guide}. * * For more programmatic querying use lunr.Index#query. * * @param {lunr.Index~QueryString} queryString - A string containing a lunr query. * @throws {lunr.QueryParseError} If the passed query string cannot be parsed. * @returns {lunr.Index~Result[]} */ lunr.Index.prototype.search = function (queryString) { return this.query(function (query) { var parser = new lunr.QueryParser(queryString, query) parser.parse() }) } /** * A query builder callback provides a query object to be used to express * the query to perform on the index. * * @callback lunr.Index~queryBuilder * @param {lunr.Query} query - The query object to build up. * @this lunr.Query */ /** * Performs a query against the index using the yielded lunr.Query object. * * If performing programmatic queries against the index, this method is preferred * over lunr.Index#search so as to avoid the additional query parsing overhead. * * A query object is yielded to the supplied function which should be used to * express the query to be run against the index. * * Note that although this function takes a callback parameter it is _not_ an * asynchronous operation, the callback is just yielded a query object to be * customized. * * @param {lunr.Index~queryBuilder} fn - A function that is used to build the query. * @returns {lunr.Index~Result[]} */ lunr.Index.prototype.query = function (fn) { // for each query clause // * process terms // * expand terms from token set // * find matching documents and metadata // * get document vectors // * score documents var query = new lunr.Query(this.fields), matchingFields = Object.create(null), queryVectors = Object.create(null), termFieldCache = Object.create(null), requiredMatches = Object.create(null), prohibitedMatches = Object.create(null) /* * To support field level boosts a query vector is created per * field. An empty vector is eagerly created to support negated * queries. */ for (var i = 0; i Extracting a nested field * function (doc) { return doc.nested.field } */ /** * Adds a field to the list of document fields that will be indexed. Every document being * indexed should have this field. Null values for this field in indexed documents will * not cause errors but will limit the chance of that document being retrieved by searches. * * All fields should be added before adding documents to the index. Adding fields after * a document has been indexed will have no effect on already indexed documents. * * Fields can be boosted at build time. This allows terms within that field to have more * importance when ranking search results. Use a field boost to specify that matches within * one field are more important than other fields. * * @param {string} fieldName - The name of a field to index in all documents. * @param {object} attributes - Optional attributes associated with this field. * @param {number} [attributes.boost=1] - Boost applied to all terms within this field. * @param {fieldExtractor} [attributes.extractor] - Function to extract a field from a document. * @throws {RangeError} fieldName cannot contain unsupported characters '/' */ lunr.Builder.prototype.field = function (fieldName, attributes) { if (/\\//.test(fieldName)) { throw new RangeError (\"Field '\" + fieldName + \"' contains illegal character '/'\") } this._fields[fieldName] = attributes || {} } /** * A parameter to tune the amount of field length normalisation that is applied when * calculating relevance scores. A value of 0 will completely disable any normalisation * and a value of 1 will fully normalise field lengths. The default is 0.75. Values of b * will be clamped to the range 0 - 1. * * @param {number} number - The value to set for this tuning parameter. */ lunr.Builder.prototype.b = function (number) { if (number 1) { this._b = 1 } else { this._b = number } } /** * A parameter that controls the speed at which a rise in term frequency results in term * frequency saturation. The default value is 1.2. Setting this to a higher value will give * slower saturation levels, a lower value will result in quicker saturation. * * @param {number} number - The value to set for this tuning parameter. */ lunr.Builder.prototype.k1 = function (number) { this._k1 = number } /** * Adds a document to the index. * * Before adding fields to the index the index should have been fully setup, with the document * ref and all fields to index already having been specified. * * The document must have a field name as specified by the ref (by default this is 'id') and * it should have all fields defined for indexing, though null or undefined values will not * cause errors. * * Entire documents can be boosted at build time. Applying a boost to a document indicates that * this document should rank higher in search results than other documents. * * @param {object} doc - The document to add to the index. * @param {object} attributes - Optional attributes associated with this document. * @param {number} [attributes.boost=1] - Boost applied to all terms within this document. */ lunr.Builder.prototype.add = function (doc, attributes) { var docRef = doc[this._ref], fields = Object.keys(this._fields) this._documents[docRef] = attributes || {} this.documentCount += 1 for (var i = 0; i query term with trailing wildcard * query.term('foo', { wildcard: lunr.Query.wildcard.TRAILING }) * @example query term with leading and trailing wildcard * query.term('foo', { * wildcard: lunr.Query.wildcard.LEADING | lunr.Query.wildcard.TRAILING * }) */ lunr.Query.wildcard = new String (\"*\") lunr.Query.wildcard.NONE = 0 lunr.Query.wildcard.LEADING = 1 lunr.Query.wildcard.TRAILING = 2 /** * Constants for indicating what kind of presence a term must have in matching documents. * * @constant * @enum {number} * @see lunr.Query~Clause * @see lunr.Query#clause * @see lunr.Query#term * @example query term with required presence * query.term('foo', { presence: lunr.Query.presence.REQUIRED }) */ lunr.Query.presence = { /** * Term's presence in a document is optional, this is the default value. */ OPTIONAL: 1, /** * Term's presence in a document is required, documents that do not contain * this term will not be returned. */ REQUIRED: 2, /** * Term's presence in a document is prohibited, documents that do contain * this term will not be returned. */ PROHIBITED: 3 } /** * A single clause in a {@link lunr.Query} contains a term and details on how to * match that term against a {@link lunr.Index}. * * @typedef {Object} lunr.Query~Clause * @property {string[]} fields - The fields in an index this clause should be matched against. * @property {number} [boost=1] - Any boost that should be applied when matching this clause. * @property {number} [editDistance] - Whether the term should have fuzzy matching applied, and how fuzzy the match should be. * @property {boolean} [usePipeline] - Whether the term should be passed through the search pipeline. * @property {number} [wildcard=lunr.Query.wildcard.NONE] - Whether the term should have wildcards appended or prepended. * @property {number} [presence=lunr.Query.presence.OPTIONAL] - The terms presence in any matching documents. */ /** * Adds a {@link lunr.Query~Clause} to this query. * * Unless the clause contains the fields to be matched all fields will be matched. In addition * a default boost of 1 is applied to the clause. * * @param {lunr.Query~Clause} clause - The clause to add to this query. * @see lunr.Query~Clause * @returns {lunr.Query} */ lunr.Query.prototype.clause = function (clause) { if (!('fields' in clause)) { clause.fields = this.allFields } if (!('boost' in clause)) { clause.boost = 1 } if (!('usePipeline' in clause)) { clause.usePipeline = true } if (!('wildcard' in clause)) { clause.wildcard = lunr.Query.wildcard.NONE } if ((clause.wildcard \u0026 lunr.Query.wildcard.LEADING) \u0026\u0026 (clause.term.charAt(0) != lunr.Query.wildcard)) { clause.term = \"*\" + clause.term } if ((clause.wildcard \u0026 lunr.Query.wildcard.TRAILING) \u0026\u0026 (clause.term.slice(-1) != lunr.Query.wildcard)) { clause.term = \"\" + clause.term + \"*\" } if (!('presence' in clause)) { clause.presence = lunr.Query.presence.OPTIONAL } this.clauses.push(clause) return this } /** * A negated query is one in which every clause has a presence of * prohibited. These queries require some special processing to return * the expected results. * * @returns boolean */ lunr.Query.prototype.isNegated = function () { for (var i = 0; i adding a single term to a query * query.term(\"foo\") * @example adding a single term to a query and specifying search fields, term boost and automatic trailing wildcard * query.term(\"foo\", { * fields: [\"title\"], * boost: 10, * wildcard: lunr.Query.wildcard.TRAILING * }) * @example using lunr.tokenizer to convert a string to tokens before using them as terms * query.term(lunr.tokenizer(\"foo bar\")) */ lunr.Query.prototype.term = function (term, options) { if (Array.isArray(term)) { term.forEach(function (t) { this.term(t, lunr.utils.clone(options)) }, this) return this } var clause = options || {} clause.term = term.toString() this.clause(clause) return this } lunr.QueryParseError = function (message, start, end) { this.name = \"QueryParseError\" this.message = message this.start = start this.end = end } lunr.QueryParseError.prototype = new Error lunr.QueryLexer = function (str) { this.lexemes = [] this.str = str this.length = str.length this.pos = 0 this.start = 0 this.escapeCharPositions = [] } lunr.QueryLexer.prototype.run = function () { var state = lunr.QueryLexer.lexText while (state) { state = state(this) } } lunr.QueryLexer.prototype.sliceString = function () { var subSlices = [], sliceStart = this.start, sliceEnd = this.pos for (var i = 0; i = this.length) { return lunr.QueryLexer.EOS } var char = this.str.charAt(this.pos) this.pos += 1 return char } lunr.QueryLexer.prototype.width = function () { return this.pos - this.start } lunr.QueryLexer.prototype.ignore = function () { if (this.start == this.pos) { this.pos += 1 } this.start = this.pos } lunr.QueryLexer.prototype.backup = function () { this.pos -= 1 } lunr.QueryLexer.prototype.acceptDigitRun = function () { var char, charCode do { char = this.next() charCode = char.charCodeAt(0) } while (charCode  47 \u0026\u0026 charCode 1) { lexer.backup() lexer.emit(lunr.QueryLexer.TERM) } lexer.ignore() if (lexer.more()) { return lunr.QueryLexer.lexText } } lunr.QueryLexer.lexEditDistance = function (lexer) { lexer.ignore() lexer.acceptDigitRun() lexer.emit(lunr.QueryLexer.EDIT_DISTANCE) return lunr.QueryLexer.lexText } lunr.QueryLexer.lexBoost = function (lexer) { lexer.ignore() lexer.acceptDigitRun() lexer.emit(lunr.QueryLexer.BOOST) return lunr.QueryLexer.lexText } lunr.QueryLexer.lexEOS = function (lexer) { if (lexer.width()  0) { lexer.emit(lunr.QueryLexer.TERM) } } // This matches the separator used when tokenising fields // within a document. These should match otherwise it is // not possible to search for some tokens within a document. // // It is possible for the user to change the separator on the // tokenizer so it _might_ clash with any other of the special // characters already used within the search string, e.g. :. // // This means that it is possible to change the separator in // such a way that makes some words unsearchable using a search // string. lunr.QueryLexer.termSeparator = lunr.tokenizer.separator lunr.QueryLexer.lexText = function (lexer) { while (true) { var char = lexer.next() if (char == lunr.QueryLexer.EOS) { return lunr.QueryLexer.lexEOS } // Escape character is '\\' if (char.charCodeAt(0) == 92) { lexer.escapeCharacter() continue } if (char == \":\") { return lunr.QueryLexer.lexField } if (char == \"~\") { lexer.backup() if (lexer.width()  0) { lexer.emit(lunr.QueryLexer.TERM) } return lunr.QueryLexer.lexEditDistance } if (char == \"^\") { lexer.backup() if (lexer.width()  0) { lexer.emit(lunr.QueryLexer.TERM) } return lunr.QueryLexer.lexBoost } // \"+\" indicates term presence is required // checking for length to ensure that only // leading \"+\" are considered if (char == \"+\" \u0026\u0026 lexer.width() === 1) { lexer.emit(lunr.QueryLexer.PRESENCE) return lunr.QueryLexer.lexText } // \"-\" indicates term presence is prohibited // checking for length to ensure that only // leading \"-\" are considered if (char == \"-\" \u0026\u0026 lexer.width() === 1) { lexer.emit(lunr.QueryLexer.PRESENCE) return lunr.QueryLexer.lexText } if (char.match(lunr.QueryLexer.termSeparator)) { return lunr.QueryLexer.lexTerm } } } lunr.QueryParser = function (str, query) { this.lexer = new lunr.QueryLexer (str) this.query = query this.currentClause = {} this.lexemeIdx = 0 } lunr.QueryParser.prototype.parse = function () { this.lexer.run() this.lexemes = this.lexer.lexemes var state = lunr.QueryParser.parseClause while (state) { state = state(this) } return this.query } lunr.QueryParser.prototype.peekLexeme = function () { return this.lexemes[this.lexemeIdx] } lunr.QueryParser.prototype.consumeLexeme = function () { var lexeme = this.peekLexeme() this.lexemeIdx += 1 return lexeme } lunr.QueryParser.prototype.nextClause = function () { var completedClause = this.currentClause this.query.clause(completedClause) this.currentClause = {} } lunr.QueryParser.parseClause = function (parser) { var lexeme = parser.peekLexeme() if (lexeme == undefined) { return } switch (lexeme.type) { case lunr.QueryLexer.PRESENCE: return lunr.QueryParser.parsePresence case lunr.QueryLexer.FIELD: return lunr.QueryParser.parseField case lunr.QueryLexer.TERM: return lunr.QueryParser.parseTerm default: var errorMessage = \"expected either a field or a term, found \" + lexeme.type if (lexeme.str.length = 1) { errorMessage += \" with value '\" + lexeme.str + \"'\" } throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end) } } lunr.QueryParser.parsePresence = function (parser) { var lexeme = parser.consumeLexeme() if (lexeme == undefined) { return } switch (lexeme.str) { case \"-\": parser.currentClause.presence = lunr.Query.presence.PROHIBITED break case \"+\": parser.currentClause.presence = lunr.Query.presence.REQUIRED break default: var errorMessage = \"unrecognised presence operator'\" + lexeme.str + \"'\" throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end) } var nextLexeme = parser.peekLexeme() if (nextLexeme == undefined) { var errorMessage = \"expecting term or field, found nothing\" throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end) } switch (nextLexeme.type) { case lunr.QueryLexer.FIELD: return lunr.QueryParser.parseField case lunr.QueryLexer.TERM: return lunr.QueryParser.parseTerm default: var errorMessage = \"expecting term or field, found '\" + nextLexeme.type + \"'\" throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end) } } lunr.QueryParser.parseField = function (parser) { var lexeme = parser.consumeLexeme() if (lexeme == undefined) { return } if (parser.query.allFields.indexOf(lexeme.str) == -1) { var possibleFields = parser.query.allFields.map(function (f) { return \"'\" + f + \"'\" }).join(', '), errorMessage = \"unrecognised field '\" + lexeme.str + \"', possible fields: \" + possibleFields throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end) } parser.currentClause.fields = [lexeme.str] var nextLexeme = parser.peekLexeme() if (nextLexeme == undefined) { var errorMessage = \"expecting term, found nothing\" throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end) } switch (nextLexeme.type) { case lunr.QueryLexer.TERM: return lunr.QueryParser.parseTerm default: var errorMessage = \"expecting term, found '\" + nextLexeme.type + \"'\" throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end) } } lunr.QueryParser.parseTerm = function (parser) { var lexeme = parser.consumeLexeme() if (lexeme == undefined) { return } parser.currentClause.term = lexeme.str.toLowerCase() if (lexeme.str.indexOf(\"*\") != -1) { parser.currentClause.usePipeline = false } var nextLexeme = parser.peekLexeme() if (nextLexeme == undefined) { parser.nextClause() return } switch (nextLexeme.type) { case lunr.QueryLexer.TERM: parser.nextClause() return lunr.QueryParser.parseTerm case lunr.QueryLexer.FIELD: parser.nextClause() return lunr.QueryParser.parseField case lunr.QueryLexer.EDIT_DISTANCE: return lunr.QueryParser.parseEditDistance case lunr.QueryLexer.BOOST: return lunr.QueryParser.parseBoost case lunr.QueryLexer.PRESENCE: parser.nextClause() return lunr.QueryParser.parsePresence default: var errorMessage = \"Unexpected lexeme type '\" + nextLexeme.type + \"'\" throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end) } } lunr.QueryParser.parseEditDistance = function (parser) { var lexeme = parser.consumeLexeme() if (lexeme == undefined) { return } var editDistance = parseInt(lexeme.str, 10) if (isNaN(editDistance)) { var errorMessage = \"edit distance must be numeric\" throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end) } parser.currentClause.editDistance = editDistance var nextLexeme = parser.peekLexeme() if (nextLexeme == undefined) { parser.nextClause() return } switch (nextLexeme.type) { case lunr.QueryLexer.TERM: parser.nextClause() return lunr.QueryParser.parseTerm case lunr.QueryLexer.FIELD: parser.nextClause() return lunr.QueryParser.parseField case lunr.QueryLexer.EDIT_DISTANCE: return lunr.QueryParser.parseEditDistance case lunr.QueryLexer.BOOST: return lunr.QueryParser.parseBoost case lunr.QueryLexer.PRESENCE: parser.nextClause() return lunr.QueryParser.parsePresence default: var errorMessage = \"Unexpected lexeme type '\" + nextLexeme.type + \"'\" throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end) } } lunr.QueryParser.parseBoost = function (parser) { var lexeme = parser.consumeLexeme() if (lexeme == undefined) { return } var boost = parseInt(lexeme.str, 10) if (isNaN(boost)) { var errorMessage = \"boost must be numeric\" throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end) } parser.currentClause.boost = boost var nextLexeme = parser.peekLexeme() if (nextLexeme == undefined) { parser.nextClause() return } switch (nextLexeme.type) { case lunr.QueryLexer.TERM: parser.nextClause() return lunr.QueryParser.parseTerm case lunr.QueryLexer.FIELD: parser.nextClause() return lunr.QueryParser.parseField case lunr.QueryLexer.EDIT_DISTANCE: return lunr.QueryParser.parseEditDistance case lunr.QueryLexer.BOOST: return lunr.QueryParser.parseBoost case lunr.QueryLexer.PRESENCE: parser.nextClause() return lunr.QueryParser.parsePresence default: var errorMessage = \"Unexpected lexeme type '\" + nextLexeme.type + \"'\" throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end) } } /** * export the module via AMD, CommonJS or as a browser global * Export code from https://github.com/umdjs/umd/blob/master/returnExports.js */ ;(function (root, factory) { if (typeof define === 'function' \u0026\u0026 define.amd) { // AMD. Register as an anonymous module. define(factory) } else if (typeof exports === 'object') { /** * Node. Does not work with strict CommonJS, but * only CommonJS-like enviroments that support module.exports, * like Node. */ module.exports = factory() } else { // Browser globals (root is window) root.lunr = factory() } }(this, function () { /** * Just return a value to define the module export. * This example returns an object, but the module * can return a function as the exported value. */ return lunr })) })();  // define globale variables var idx, searchInput, searchResults = null var documents = [] function renderSearchResults(results){ if (results.length  0) { // show max 10 results if (results.length  9){ results = results.slice(0,10) } // reset search results searchResults.innerHTML = '' // append results results.forEach(result = { // create result item var article = document.createElement('article') article.innerHTML = ` ${documents[result.ref].title}   ` searchResults.appendChild(article) }) // if results are empty } else { searchResults.innerHTML = 'Ingen resultater.\n' } } function registerSearchHandler() { // register on input event searchInput.oninput = function(event) { // remove search results if the user empties the search input field if (searchInput.value == '') { searchResults.innerHTML = '' } else { // get input value var query = event.target.value // run fuzzy search var results = idx.search(query + '*') // render results renderSearchResults(results) } } // set focus on search input and remove loading placeholder searchInput.focus() searchInput.placeholder = '⌕' } window.onload = function() { // get dom elements searchInput = document.getElementById('search-input') searchResults = document.getElementById('search-results') // request and index documents fetch('/index.json', { method: 'get' }).then( res = res.json() ).then( res = { // index document idx = lunr(function() { this.ref('url') this.field('title') this.field('content') res.forEach(function(doc) { this.add(doc) documents[doc.url] = { 'title': doc.title, 'content': doc.content, } }, this) }) // data is loaded, next register handler registerSearchHandler() } ).catch( err = { searchResults.innerHTML = `${err}\n` } ) }  Tast søgeord i feltet Noget du ikke fandt? Kontakt Kiils    input::placeholder { text-align: right; }  "
    }
    
]
